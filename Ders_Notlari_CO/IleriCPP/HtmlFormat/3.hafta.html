<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>3&period;Hafta</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

/* From extension bierner.markdown-preview-github-styles */
html,
body,
.github-markdown-body {
    padding: 0 !important;
    max-width: auto !important;
}

.github-markdown-body {
    background-color: var(--color-canvas-default);
    color: var(--color-fg-default);
}

.github-markdown-body {
    border: 1px solid transparent;
    box-sizing: border-box;
    margin: 0 auto;
    width: 100% !important;
}

.github-markdown-content {
    padding: 32px !important;
    max-width: 980px;
    min-width: 200px;
    margin: 0 auto;
}


.vscode-body.scrollBeyondLastLine {
    margin-bottom: 0;
}
.vscode-body.scrollBeyondLastLine .github-markdown-body {
    padding-bottom: calc(100vh + 10px) !important;
}

.github-markdown-body blockquote {
    background-color: initial;
}

.github-markdown-body pre {
    color: initial;
    border: none;
}

.github-markdown-body code {
    color: inherit;
}

.github-markdown-body pre code {
    color: initial;
}

.github-markdown-body code > div {
    background: none
}

.github-markdown-body.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.github-markdown-body p,
.github-markdown-body blockquote,
.github-markdown-body ul,
.github-markdown-body ol,
.github-markdown-body dl,
.github-markdown-body table,
.github-markdown-body pre {
  margin-top: 16px;
  margin-bottom: 16px;
}

.vscode-dark.showEditorSelection .code-line:hover:before {
    border-left: 3px solid var(--color-fg-default);
}
.github-markdown-body {
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  margin: 0;
  color: var(--fgColor-default, var(--color-fg-default));
  background-color: var(--bgColor-default, var(--color-canvas-default));
  font-family: -apple-system,BlinkMacSystemFont,"Segoe UI","Noto Sans",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji";
  font-size: 16px;
  line-height: 1.5;
  word-wrap: break-word;
}

.github-markdown-body .octicon {
  display: inline-block;
  fill: currentColor;
  vertical-align: text-bottom;
}

.github-markdown-body h1:hover .anchor .octicon-link:before,
.github-markdown-body h2:hover .anchor .octicon-link:before,
.github-markdown-body h3:hover .anchor .octicon-link:before,
.github-markdown-body h4:hover .anchor .octicon-link:before,
.github-markdown-body h5:hover .anchor .octicon-link:before,
.github-markdown-body h6:hover .anchor .octicon-link:before {
  width: 16px;
  height: 16px;
  content: ' ';
  display: inline-block;
  background-color: currentColor;
  -webkit-mask-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'><path fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'></path></svg>");
  mask-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'><path fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'></path></svg>");
}

.github-markdown-body details,
.github-markdown-body figcaption,
.github-markdown-body figure {
  display: block;
}

.github-markdown-body summary {
  display: list-item;
}

.github-markdown-body [hidden] {
  display: none !important;
}

.github-markdown-body a {
  background-color: transparent;
  color: var(--fgColor-accent, var(--color-accent-fg));
  text-decoration: none;
}

.github-markdown-body abbr[title] {
  border-bottom: none;
  text-decoration: underline dotted;
}

.github-markdown-body b,
.github-markdown-body strong {
  font-weight: var(--base-text-weight-semibold, 600);
}

.github-markdown-body dfn {
  font-style: italic;
}

.github-markdown-body h1 {
  margin: .67em 0;
  font-weight: var(--base-text-weight-semibold, 600);
  padding-bottom: .3em;
  font-size: 2em;
  border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));
}

.github-markdown-body mark {
  background-color: var(--bgColor-attention-muted, var(--color-attention-subtle));
  color: var(--fgColor-default, var(--color-fg-default));
}

.github-markdown-body small {
  font-size: 90%;
}

.github-markdown-body sub,
.github-markdown-body sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

.github-markdown-body sub {
  bottom: -0.25em;
}

.github-markdown-body sup {
  top: -0.5em;
}

.github-markdown-body img {
  border-style: none;
  max-width: 100%;
  box-sizing: content-box;
  background-color: var(--bgColor-default, var(--color-canvas-default));
}

.github-markdown-body code,
.github-markdown-body kbd,
.github-markdown-body pre,
.github-markdown-body samp {
  font-family: monospace;
  font-size: 1em;
}

.github-markdown-body figure {
  margin: 1em 40px;
}

.github-markdown-body hr {
  box-sizing: content-box;
  overflow: hidden;
  background: transparent;
  border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));
  height: .25em;
  padding: 0;
  margin: 24px 0;
  background-color: var(--borderColor-default, var(--color-border-default));
  border: 0;
}

.github-markdown-body input {
  font: inherit;
  margin: 0;
  overflow: visible;
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
}

.github-markdown-body [type=button],
.github-markdown-body [type=reset],
.github-markdown-body [type=submit] {
  -webkit-appearance: button;
}

.github-markdown-body [type=checkbox],
.github-markdown-body [type=radio] {
  box-sizing: border-box;
  padding: 0;
}

.github-markdown-body [type=number]::-webkit-inner-spin-button,
.github-markdown-body [type=number]::-webkit-outer-spin-button {
  height: auto;
}

.github-markdown-body [type=search]::-webkit-search-cancel-button,
.github-markdown-body [type=search]::-webkit-search-decoration {
  -webkit-appearance: none;
}

.github-markdown-body ::-webkit-input-placeholder {
  color: inherit;
  opacity: .54;
}

.github-markdown-body ::-webkit-file-upload-button {
  -webkit-appearance: button;
  font: inherit;
}

.github-markdown-body a:hover {
  text-decoration: underline;
}

.github-markdown-body ::placeholder {
  color: var(--fgColor-muted, var(--color-fg-subtle));
  opacity: 1;
}

.github-markdown-body hr::before {
  display: table;
  content: "";
}

.github-markdown-body hr::after {
  display: table;
  clear: both;
  content: "";
}

.github-markdown-body table {
  border-spacing: 0;
  border-collapse: collapse;
  display: block;
  width: max-content;
  max-width: 100%;
  overflow: auto;
}

.github-markdown-body td,
.github-markdown-body th {
  padding: 0;
}

.github-markdown-body details summary {
  cursor: pointer;
}

.github-markdown-body details:not([open])>*:not(summary) {
  display: none !important;
}

.github-markdown-body a:focus,
.github-markdown-body [role=button]:focus,
.github-markdown-body input[type=radio]:focus,
.github-markdown-body input[type=checkbox]:focus {
  outline: 2px solid var(--focus-outlineColor, var(--color-accent-fg));
  outline-offset: -2px;
  box-shadow: none;
}

.github-markdown-body a:focus:not(:focus-visible),
.github-markdown-body [role=button]:focus:not(:focus-visible),
.github-markdown-body input[type=radio]:focus:not(:focus-visible),
.github-markdown-body input[type=checkbox]:focus:not(:focus-visible) {
  outline: solid 1px transparent;
}

.github-markdown-body a:focus-visible,
.github-markdown-body [role=button]:focus-visible,
.github-markdown-body input[type=radio]:focus-visible,
.github-markdown-body input[type=checkbox]:focus-visible {
  outline: 2px solid var(--focus-outlineColor, var(--color-accent-fg));
  outline-offset: -2px;
  box-shadow: none;
}

.github-markdown-body a:not([class]):focus,
.github-markdown-body a:not([class]):focus-visible,
.github-markdown-body input[type=radio]:focus,
.github-markdown-body input[type=radio]:focus-visible,
.github-markdown-body input[type=checkbox]:focus,
.github-markdown-body input[type=checkbox]:focus-visible {
  outline-offset: 0;
}

.github-markdown-body kbd {
  display: inline-block;
  padding: 3px 5px;
  font: 11px ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;
  line-height: 10px;
  color: var(--fgColor-default, var(--color-fg-default));
  vertical-align: middle;
  background-color: var(--bgColor-muted, var(--color-canvas-subtle));
  border: solid 1px var(--borderColor-neutral-muted, var(--color-neutral-muted));
  border-bottom-color: var(--borderColor-neutral-muted, var(--color-neutral-muted));
  border-radius: 6px;
  box-shadow: inset 0 -1px 0 var(--borderColor-neutral-muted, var(--color-neutral-muted));
}

.github-markdown-body h1,
.github-markdown-body h2,
.github-markdown-body h3,
.github-markdown-body h4,
.github-markdown-body h5,
.github-markdown-body h6 {
  margin-top: 24px;
  margin-bottom: 16px;
  font-weight: var(--base-text-weight-semibold, 600);
  line-height: 1.25;
}

.github-markdown-body h2 {
  font-weight: var(--base-text-weight-semibold, 600);
  padding-bottom: .3em;
  font-size: 1.5em;
  border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));
}

.github-markdown-body h3 {
  font-weight: var(--base-text-weight-semibold, 600);
  font-size: 1.25em;
}

.github-markdown-body h4 {
  font-weight: var(--base-text-weight-semibold, 600);
  font-size: 1em;
}

.github-markdown-body h5 {
  font-weight: var(--base-text-weight-semibold, 600);
  font-size: .875em;
}

.github-markdown-body h6 {
  font-weight: var(--base-text-weight-semibold, 600);
  font-size: .85em;
  color: var(--fgColor-muted, var(--color-fg-muted));
}

.github-markdown-body p {
  margin-top: 0;
  margin-bottom: 10px;
}

.github-markdown-body blockquote {
  margin: 0;
  padding: 0 1em;
  color: var(--fgColor-muted, var(--color-fg-muted));
  border-left: .25em solid var(--borderColor-default, var(--color-border-default));
}

.github-markdown-body ul,
.github-markdown-body ol {
  margin-top: 0;
  margin-bottom: 0;
  padding-left: 2em;
}

.github-markdown-body ol ol,
.github-markdown-body ul ol {
  list-style-type: lower-roman;
}

.github-markdown-body ul ul ol,
.github-markdown-body ul ol ol,
.github-markdown-body ol ul ol,
.github-markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.github-markdown-body dd {
  margin-left: 0;
}

.github-markdown-body tt,
.github-markdown-body code,
.github-markdown-body samp {
  font-family: ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;
  font-size: 12px;
}

.github-markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
  font-family: ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;
  font-size: 12px;
  word-wrap: normal;
}

.github-markdown-body .octicon {
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.github-markdown-body input::-webkit-outer-spin-button,
.github-markdown-body input::-webkit-inner-spin-button {
  margin: 0;
  -webkit-appearance: none;
  appearance: none;
}

.github-markdown-body::before {
  display: table;
  content: "";
}

.github-markdown-body::after {
  display: table;
  clear: both;
  content: "";
}

.github-markdown-body>*:first-child {
  margin-top: 0 !important;
}

.github-markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.github-markdown-body a:not([href]) {
  color: inherit;
  text-decoration: none;
}

.github-markdown-body .absent {
  color: var(--fgColor-danger, var(--color-danger-fg));
}

.github-markdown-body .anchor {
  float: left;
  padding-right: 4px;
  margin-left: -20px;
  line-height: 1;
}

.github-markdown-body .anchor:focus {
  outline: none;
}

.github-markdown-body p,
.github-markdown-body blockquote,
.github-markdown-body ul,
.github-markdown-body ol,
.github-markdown-body dl,
.github-markdown-body table,
.github-markdown-body pre,
.github-markdown-body details {
  margin-top: 0;
  margin-bottom: 16px;
}

.github-markdown-body blockquote>:first-child {
  margin-top: 0;
}

.github-markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.github-markdown-body h1 .octicon-link,
.github-markdown-body h2 .octicon-link,
.github-markdown-body h3 .octicon-link,
.github-markdown-body h4 .octicon-link,
.github-markdown-body h5 .octicon-link,
.github-markdown-body h6 .octicon-link {
  color: var(--fgColor-default, var(--color-fg-default));
  vertical-align: middle;
  visibility: hidden;
}

.github-markdown-body h1:hover .anchor,
.github-markdown-body h2:hover .anchor,
.github-markdown-body h3:hover .anchor,
.github-markdown-body h4:hover .anchor,
.github-markdown-body h5:hover .anchor,
.github-markdown-body h6:hover .anchor {
  text-decoration: none;
}

.github-markdown-body h1:hover .anchor .octicon-link,
.github-markdown-body h2:hover .anchor .octicon-link,
.github-markdown-body h3:hover .anchor .octicon-link,
.github-markdown-body h4:hover .anchor .octicon-link,
.github-markdown-body h5:hover .anchor .octicon-link,
.github-markdown-body h6:hover .anchor .octicon-link {
  visibility: visible;
}

.github-markdown-body h1 tt,
.github-markdown-body h1 code,
.github-markdown-body h2 tt,
.github-markdown-body h2 code,
.github-markdown-body h3 tt,
.github-markdown-body h3 code,
.github-markdown-body h4 tt,
.github-markdown-body h4 code,
.github-markdown-body h5 tt,
.github-markdown-body h5 code,
.github-markdown-body h6 tt,
.github-markdown-body h6 code {
  padding: 0 .2em;
  font-size: inherit;
}

.github-markdown-body summary h1,
.github-markdown-body summary h2,
.github-markdown-body summary h3,
.github-markdown-body summary h4,
.github-markdown-body summary h5,
.github-markdown-body summary h6 {
  display: inline-block;
}

.github-markdown-body summary h1 .anchor,
.github-markdown-body summary h2 .anchor,
.github-markdown-body summary h3 .anchor,
.github-markdown-body summary h4 .anchor,
.github-markdown-body summary h5 .anchor,
.github-markdown-body summary h6 .anchor {
  margin-left: -40px;
}

.github-markdown-body summary h1,
.github-markdown-body summary h2 {
  padding-bottom: 0;
  border-bottom: 0;
}

.github-markdown-body ul.no-list,
.github-markdown-body ol.no-list {
  padding: 0;
  list-style-type: none;
}

.github-markdown-body ol[type="a s"] {
  list-style-type: lower-alpha;
}

.github-markdown-body ol[type="A s"] {
  list-style-type: upper-alpha;
}

.github-markdown-body ol[type="i s"] {
  list-style-type: lower-roman;
}

.github-markdown-body ol[type="I s"] {
  list-style-type: upper-roman;
}

.github-markdown-body ol[type="1"] {
  list-style-type: decimal;
}

.github-markdown-body div>ol:not([type]) {
  list-style-type: decimal;
}

.github-markdown-body ul ul,
.github-markdown-body ul ol,
.github-markdown-body ol ol,
.github-markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.github-markdown-body li>p {
  margin-top: 16px;
}

.github-markdown-body li+li {
  margin-top: .25em;
}

.github-markdown-body dl {
  padding: 0;
}

.github-markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: var(--base-text-weight-semibold, 600);
}

.github-markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.github-markdown-body table th {
  font-weight: var(--base-text-weight-semibold, 600);
}

.github-markdown-body table th,
.github-markdown-body table td {
  padding: 6px 13px;
  border: 1px solid var(--borderColor-default, var(--color-border-default));
}

.github-markdown-body table td>:last-child {
  margin-bottom: 0;
}

.github-markdown-body table tr {
  background-color: var(--bgColor-default, var(--color-canvas-default));
  border-top: 1px solid var(--borderColor-muted, var(--color-border-muted));
}

.github-markdown-body table tr:nth-child(2n) {
  background-color: var(--bgColor-muted, var(--color-canvas-subtle));
}

.github-markdown-body table img {
  background-color: transparent;
}

.github-markdown-body img[align=right] {
  padding-left: 20px;
}

.github-markdown-body img[align=left] {
  padding-right: 20px;
}

.github-markdown-body .emoji {
  max-width: none;
  vertical-align: text-top;
  background-color: transparent;
}

.github-markdown-body span.frame {
  display: block;
  overflow: hidden;
}

.github-markdown-body span.frame>span {
  display: block;
  float: left;
  width: auto;
  padding: 7px;
  margin: 13px 0 0;
  overflow: hidden;
  border: 1px solid var(--borderColor-default, var(--color-border-default));
}

.github-markdown-body span.frame span img {
  display: block;
  float: left;
}

.github-markdown-body span.frame span span {
  display: block;
  padding: 5px 0 0;
  clear: both;
  color: var(--fgColor-default, var(--color-fg-default));
}

.github-markdown-body span.align-center {
  display: block;
  overflow: hidden;
  clear: both;
}

.github-markdown-body span.align-center>span {
  display: block;
  margin: 13px auto 0;
  overflow: hidden;
  text-align: center;
}

.github-markdown-body span.align-center span img {
  margin: 0 auto;
  text-align: center;
}

.github-markdown-body span.align-right {
  display: block;
  overflow: hidden;
  clear: both;
}

.github-markdown-body span.align-right>span {
  display: block;
  margin: 13px 0 0;
  overflow: hidden;
  text-align: right;
}

.github-markdown-body span.align-right span img {
  margin: 0;
  text-align: right;
}

.github-markdown-body span.float-left {
  display: block;
  float: left;
  margin-right: 13px;
  overflow: hidden;
}

.github-markdown-body span.float-left span {
  margin: 13px 0 0;
}

.github-markdown-body span.float-right {
  display: block;
  float: right;
  margin-left: 13px;
  overflow: hidden;
}

.github-markdown-body span.float-right>span {
  display: block;
  margin: 13px auto 0;
  overflow: hidden;
  text-align: right;
}

.github-markdown-body code,
.github-markdown-body tt {
  padding: .2em .4em;
  margin: 0;
  font-size: 85%;
  white-space: break-spaces;
  background-color: var(--bgColor-neutral-muted, var(--color-neutral-muted));
  border-radius: 6px;
}

.github-markdown-body code br,
.github-markdown-body tt br {
  display: none;
}

.github-markdown-body del code {
  text-decoration: inherit;
}

.github-markdown-body samp {
  font-size: 85%;
}

.github-markdown-body pre code {
  font-size: 100%;
}

.github-markdown-body pre>code {
  padding: 0;
  margin: 0;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.github-markdown-body .highlight {
  margin-bottom: 16px;
}

.github-markdown-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.github-markdown-body .highlight pre,
.github-markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  color: var(--fgColor-default, var(--color-fg-default));
  background-color: var(--bgColor-muted, var(--color-canvas-subtle));
  border-radius: 6px;
}

.github-markdown-body pre code,
.github-markdown-body pre tt {
  display: inline;
  max-width: auto;
  padding: 0;
  margin: 0;
  overflow: visible;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.github-markdown-body .csv-data td,
.github-markdown-body .csv-data th {
  padding: 5px;
  overflow: hidden;
  font-size: 12px;
  line-height: 1;
  text-align: left;
  white-space: nowrap;
}

.github-markdown-body .csv-data .blob-num {
  padding: 10px 8px 9px;
  text-align: right;
  background: var(--bgColor-default, var(--color-canvas-default));
  border: 0;
}

.github-markdown-body .csv-data tr {
  border-top: 0;
}

.github-markdown-body .csv-data th {
  font-weight: var(--base-text-weight-semibold, 600);
  background: var(--bgColor-muted, var(--color-canvas-subtle));
  border-top: 0;
}

.github-markdown-body [data-footnote-ref]::before {
  content: "[";
}

.github-markdown-body [data-footnote-ref]::after {
  content: "]";
}

.github-markdown-body .footnotes {
  font-size: 12px;
  color: var(--fgColor-muted, var(--color-fg-muted));
  border-top: 1px solid var(--borderColor-default, var(--color-border-default));
}

.github-markdown-body .footnotes ol {
  padding-left: 16px;
}

.github-markdown-body .footnotes ol ul {
  display: inline-block;
  padding-left: 16px;
  margin-top: 16px;
}

.github-markdown-body .footnotes li {
  position: relative;
}

.github-markdown-body .footnotes li:target::before {
  position: absolute;
  top: -8px;
  right: -8px;
  bottom: -8px;
  left: -24px;
  pointer-events: none;
  content: "";
  border: 2px solid var(--borderColor-accent-emphasis, var(--color-accent-emphasis));
  border-radius: 6px;
}

.github-markdown-body .footnotes li:target {
  color: var(--fgColor-default, var(--color-fg-default));
}

.github-markdown-body .footnotes .data-footnote-backref g-emoji {
  font-family: monospace;
}

.github-markdown-body [popover] {
  background-color: canvas;
  border: initial solid;
  border-color: initial;
  border-image: initial;
  color: initial;
  height: fit-content;
  inset: 0;
  margin: auto;
  overflow: auto;
  padding: .25em;
  position: fixed;
  width: fit-content;
  z-index: 2147483647;
}

.github-markdown-body [popover]:not(.\:popover-open) {
  display: none;
}

.github-markdown-body [popover]:is(dialog[open]) {
  display: revert;
}

.github-markdown-body [anchor].\:popover-open {
  inset: auto;
}

.github-markdown-body .pl-c {
  color: var(--color-prettylights-syntax-comment);
}

.github-markdown-body .pl-c1,
.github-markdown-body .pl-s .pl-v {
  color: var(--color-prettylights-syntax-constant);
}

.github-markdown-body .pl-e,
.github-markdown-body .pl-en {
  color: var(--color-prettylights-syntax-entity);
}

.github-markdown-body .pl-smi,
.github-markdown-body .pl-s .pl-s1 {
  color: var(--color-prettylights-syntax-storage-modifier-import);
}

.github-markdown-body .pl-ent {
  color: var(--color-prettylights-syntax-entity-tag);
}

.github-markdown-body .pl-k {
  color: var(--color-prettylights-syntax-keyword);
}

.github-markdown-body .pl-s,
.github-markdown-body .pl-pds,
.github-markdown-body .pl-s .pl-pse .pl-s1,
.github-markdown-body .pl-sr,
.github-markdown-body .pl-sr .pl-cce,
.github-markdown-body .pl-sr .pl-sre,
.github-markdown-body .pl-sr .pl-sra {
  color: var(--color-prettylights-syntax-string);
}

.github-markdown-body .pl-v,
.github-markdown-body .pl-smw {
  color: var(--color-prettylights-syntax-variable);
}

.github-markdown-body .pl-bu {
  color: var(--color-prettylights-syntax-brackethighlighter-unmatched);
}

.github-markdown-body .pl-ii {
  color: var(--color-prettylights-syntax-invalid-illegal-text);
  background-color: var(--color-prettylights-syntax-invalid-illegal-bg);
}

.github-markdown-body .pl-c2 {
  color: var(--color-prettylights-syntax-carriage-return-text);
  background-color: var(--color-prettylights-syntax-carriage-return-bg);
}

.github-markdown-body .pl-sr .pl-cce {
  font-weight: bold;
  color: var(--color-prettylights-syntax-string-regexp);
}

.github-markdown-body .pl-ml {
  color: var(--color-prettylights-syntax-markup-list);
}

.github-markdown-body .pl-mh,
.github-markdown-body .pl-mh .pl-en,
.github-markdown-body .pl-ms {
  font-weight: bold;
  color: var(--color-prettylights-syntax-markup-heading);
}

.github-markdown-body .pl-mi {
  font-style: italic;
  color: var(--color-prettylights-syntax-markup-italic);
}

.github-markdown-body .pl-mb {
  font-weight: bold;
  color: var(--color-prettylights-syntax-markup-bold);
}

.github-markdown-body .pl-md {
  color: var(--color-prettylights-syntax-markup-deleted-text);
  background-color: var(--color-prettylights-syntax-markup-deleted-bg);
}

.github-markdown-body .pl-mi1 {
  color: var(--color-prettylights-syntax-markup-inserted-text);
  background-color: var(--color-prettylights-syntax-markup-inserted-bg);
}

.github-markdown-body .pl-mc {
  color: var(--color-prettylights-syntax-markup-changed-text);
  background-color: var(--color-prettylights-syntax-markup-changed-bg);
}

.github-markdown-body .pl-mi2 {
  color: var(--color-prettylights-syntax-markup-ignored-text);
  background-color: var(--color-prettylights-syntax-markup-ignored-bg);
}

.github-markdown-body .pl-mdr {
  font-weight: bold;
  color: var(--color-prettylights-syntax-meta-diff-range);
}

.github-markdown-body .pl-ba {
  color: var(--color-prettylights-syntax-brackethighlighter-angle);
}

.github-markdown-body .pl-sg {
  color: var(--color-prettylights-syntax-sublimelinter-gutter-mark);
}

.github-markdown-body .pl-corl {
  text-decoration: underline;
  color: var(--color-prettylights-syntax-constant-other-reference-link);
}

.github-markdown-body g-emoji {
  display: inline-block;
  min-width: 1ch;
  font-family: "Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";
  font-size: 1em;
  font-style: normal !important;
  font-weight: var(--base-text-weight-normal, 400);
  line-height: 1;
  vertical-align: -0.075em;
}

.github-markdown-body g-emoji img {
  width: 1em;
  height: 1em;
}

.github-markdown-body .task-list-item {
  list-style-type: none;
}

.github-markdown-body .task-list-item label {
  font-weight: var(--base-text-weight-normal, 400);
}

.github-markdown-body .task-list-item.enabled label {
  cursor: pointer;
}

.github-markdown-body .task-list-item+.task-list-item {
  margin-top: 4px;
}

.github-markdown-body .task-list-item .handle {
  display: none;
}

.github-markdown-body .task-list-item-checkbox {
  margin: 0 .2em .25em -1.4em;
  vertical-align: middle;
}

.github-markdown-body .contains-task-list:dir(rtl) .task-list-item-checkbox {
  margin: 0 -1.6em .25em .2em;
}

.github-markdown-body .contains-task-list {
  position: relative;
}

.github-markdown-body .contains-task-list:hover .task-list-item-convert-container,
.github-markdown-body .contains-task-list:focus-within .task-list-item-convert-container {
  display: block;
  width: auto;
  height: 24px;
  overflow: visible;
  clip: auto;
}

.github-markdown-body .QueryBuilder .qb-entity {
  color: var(--color-prettylights-syntax-entity);
}

.github-markdown-body .QueryBuilder .qb-constant {
  color: var(--color-prettylights-syntax-constant);
}

.github-markdown-body ::-webkit-calendar-picker-indicator {
  filter: invert(50%);
}
[data-color-mode=light][data-light-theme=light],
[data-color-mode=dark][data-dark-theme=light],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=light],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=light] {
  /*light*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=light] {
  /*light*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=light] {
  /*light*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
}
}

[data-color-mode=light][data-light-theme=light_colorblind],
[data-color-mode=dark][data-dark-theme=light_colorblind],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=light_colorblind],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=light_colorblind] {
  /*light_colorblind*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #0550ae;
  --color-prettylights-syntax-keyword: #b35900;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #8a4600;
  --color-prettylights-syntax-brackethighlighter-unmatched: #6f3800;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #6f3800;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #b35900;
  --color-prettylights-syntax-string-regexp: #0550ae;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #6f3800;
  --color-prettylights-syntax-markup-deleted-bg: #fff5e8;
  --color-prettylights-syntax-markup-inserted-text: #0550ae;
  --color-prettylights-syntax-markup-inserted-bg: #ddf4ff;
  --color-prettylights-syntax-markup-changed-text: #8a4600;
  --color-prettylights-syntax-markup-changed-bg: #ffddb0;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #24292f;
  --color-fg-muted: #57606a;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #b35900;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=light_colorblind] {
  /*light_colorblind*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #0550ae;
  --color-prettylights-syntax-keyword: #b35900;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #8a4600;
  --color-prettylights-syntax-brackethighlighter-unmatched: #6f3800;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #6f3800;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #b35900;
  --color-prettylights-syntax-string-regexp: #0550ae;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #6f3800;
  --color-prettylights-syntax-markup-deleted-bg: #fff5e8;
  --color-prettylights-syntax-markup-inserted-text: #0550ae;
  --color-prettylights-syntax-markup-inserted-bg: #ddf4ff;
  --color-prettylights-syntax-markup-changed-text: #8a4600;
  --color-prettylights-syntax-markup-changed-bg: #ffddb0;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #24292f;
  --color-fg-muted: #57606a;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #b35900;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=light_colorblind] {
  /*light_colorblind*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #0550ae;
  --color-prettylights-syntax-keyword: #b35900;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #8a4600;
  --color-prettylights-syntax-brackethighlighter-unmatched: #6f3800;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #6f3800;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #b35900;
  --color-prettylights-syntax-string-regexp: #0550ae;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #6f3800;
  --color-prettylights-syntax-markup-deleted-bg: #fff5e8;
  --color-prettylights-syntax-markup-inserted-text: #0550ae;
  --color-prettylights-syntax-markup-inserted-bg: #ddf4ff;
  --color-prettylights-syntax-markup-changed-text: #8a4600;
  --color-prettylights-syntax-markup-changed-bg: #ffddb0;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #24292f;
  --color-fg-muted: #57606a;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #b35900;
}
}

[data-color-mode=light][data-light-theme=light_tritanopia],
[data-color-mode=dark][data-dark-theme=light_tritanopia],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=light_tritanopia],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=light_tritanopia] {
  /*light_tritanopia*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #0550ae;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #a40e26;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #0550ae;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #0550ae;
  --color-prettylights-syntax-markup-inserted-bg: #ddf4ff;
  --color-prettylights-syntax-markup-changed-text: #a40e26;
  --color-prettylights-syntax-markup-changed-bg: #ffcecb;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #24292f;
  --color-fg-muted: #57606a;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #cf222e;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=light_tritanopia] {
  /*light_tritanopia*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #0550ae;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #a40e26;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #0550ae;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #0550ae;
  --color-prettylights-syntax-markup-inserted-bg: #ddf4ff;
  --color-prettylights-syntax-markup-changed-text: #a40e26;
  --color-prettylights-syntax-markup-changed-bg: #ffcecb;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #24292f;
  --color-fg-muted: #57606a;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #cf222e;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=light_tritanopia] {
  /*light_tritanopia*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #0550ae;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #a40e26;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #0550ae;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #0550ae;
  --color-prettylights-syntax-markup-inserted-bg: #ddf4ff;
  --color-prettylights-syntax-markup-changed-text: #a40e26;
  --color-prettylights-syntax-markup-changed-bg: #ffcecb;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #24292f;
  --color-fg-muted: #57606a;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #cf222e;
}
}

[data-color-mode=light][data-light-theme=light_high_contrast],
[data-color-mode=dark][data-dark-theme=light_high_contrast],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=light_high_contrast],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=light_high_contrast] {
  /*light_high_contrast*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #66707b;
  --color-prettylights-syntax-constant: #023b95;
  --color-prettylights-syntax-entity: #512598;
  --color-prettylights-syntax-storage-modifier-import: #0e1116;
  --color-prettylights-syntax-entity-tag: #024c1a;
  --color-prettylights-syntax-keyword: #a0111f;
  --color-prettylights-syntax-string: #032563;
  --color-prettylights-syntax-variable: #702c00;
  --color-prettylights-syntax-brackethighlighter-unmatched: #6e011a;
  --color-prettylights-syntax-invalid-illegal-text: #ffffff;
  --color-prettylights-syntax-invalid-illegal-bg: #6e011a;
  --color-prettylights-syntax-carriage-return-text: #ffffff;
  --color-prettylights-syntax-carriage-return-bg: #a0111f;
  --color-prettylights-syntax-string-regexp: #024c1a;
  --color-prettylights-syntax-markup-list: #2e1800;
  --color-prettylights-syntax-markup-heading: #023b95;
  --color-prettylights-syntax-markup-italic: #0e1116;
  --color-prettylights-syntax-markup-bold: #0e1116;
  --color-prettylights-syntax-markup-deleted-text: #6e011a;
  --color-prettylights-syntax-markup-deleted-bg: #fff0ee;
  --color-prettylights-syntax-markup-inserted-text: #024c1a;
  --color-prettylights-syntax-markup-inserted-bg: #d2fedb;
  --color-prettylights-syntax-markup-changed-text: #702c00;
  --color-prettylights-syntax-markup-changed-bg: #ffc67b;
  --color-prettylights-syntax-markup-ignored-text: #e7ecf0;
  --color-prettylights-syntax-markup-ignored-bg: #023b95;
  --color-prettylights-syntax-meta-diff-range: #622cbc;
  --color-prettylights-syntax-brackethighlighter-angle: #4b535d;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #88929d;
  --color-prettylights-syntax-constant-other-reference-link: #032563;
  --color-fg-default: #0e1116;
  --color-fg-muted: #0e1116;
  --color-fg-subtle: #66707b;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #e7ecf0;
  --color-border-default: #20252c;
  --color-border-muted: #88929d;
  --color-neutral-muted: rgba(172,182,192,0.2);
  --color-accent-fg: #0349b4;
  --color-accent-emphasis: #0349b4;
  --color-attention-subtle: #fcf7be;
  --color-danger-fg: #d1242f;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=light_high_contrast] {
  /*light_high_contrast*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #66707b;
  --color-prettylights-syntax-constant: #023b95;
  --color-prettylights-syntax-entity: #512598;
  --color-prettylights-syntax-storage-modifier-import: #0e1116;
  --color-prettylights-syntax-entity-tag: #024c1a;
  --color-prettylights-syntax-keyword: #a0111f;
  --color-prettylights-syntax-string: #032563;
  --color-prettylights-syntax-variable: #702c00;
  --color-prettylights-syntax-brackethighlighter-unmatched: #6e011a;
  --color-prettylights-syntax-invalid-illegal-text: #ffffff;
  --color-prettylights-syntax-invalid-illegal-bg: #6e011a;
  --color-prettylights-syntax-carriage-return-text: #ffffff;
  --color-prettylights-syntax-carriage-return-bg: #a0111f;
  --color-prettylights-syntax-string-regexp: #024c1a;
  --color-prettylights-syntax-markup-list: #2e1800;
  --color-prettylights-syntax-markup-heading: #023b95;
  --color-prettylights-syntax-markup-italic: #0e1116;
  --color-prettylights-syntax-markup-bold: #0e1116;
  --color-prettylights-syntax-markup-deleted-text: #6e011a;
  --color-prettylights-syntax-markup-deleted-bg: #fff0ee;
  --color-prettylights-syntax-markup-inserted-text: #024c1a;
  --color-prettylights-syntax-markup-inserted-bg: #d2fedb;
  --color-prettylights-syntax-markup-changed-text: #702c00;
  --color-prettylights-syntax-markup-changed-bg: #ffc67b;
  --color-prettylights-syntax-markup-ignored-text: #e7ecf0;
  --color-prettylights-syntax-markup-ignored-bg: #023b95;
  --color-prettylights-syntax-meta-diff-range: #622cbc;
  --color-prettylights-syntax-brackethighlighter-angle: #4b535d;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #88929d;
  --color-prettylights-syntax-constant-other-reference-link: #032563;
  --color-fg-default: #0e1116;
  --color-fg-muted: #0e1116;
  --color-fg-subtle: #66707b;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #e7ecf0;
  --color-border-default: #20252c;
  --color-border-muted: #88929d;
  --color-neutral-muted: rgba(172,182,192,0.2);
  --color-accent-fg: #0349b4;
  --color-accent-emphasis: #0349b4;
  --color-attention-subtle: #fcf7be;
  --color-danger-fg: #d1242f;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=light_high_contrast] {
  /*light_high_contrast*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #66707b;
  --color-prettylights-syntax-constant: #023b95;
  --color-prettylights-syntax-entity: #512598;
  --color-prettylights-syntax-storage-modifier-import: #0e1116;
  --color-prettylights-syntax-entity-tag: #024c1a;
  --color-prettylights-syntax-keyword: #a0111f;
  --color-prettylights-syntax-string: #032563;
  --color-prettylights-syntax-variable: #702c00;
  --color-prettylights-syntax-brackethighlighter-unmatched: #6e011a;
  --color-prettylights-syntax-invalid-illegal-text: #ffffff;
  --color-prettylights-syntax-invalid-illegal-bg: #6e011a;
  --color-prettylights-syntax-carriage-return-text: #ffffff;
  --color-prettylights-syntax-carriage-return-bg: #a0111f;
  --color-prettylights-syntax-string-regexp: #024c1a;
  --color-prettylights-syntax-markup-list: #2e1800;
  --color-prettylights-syntax-markup-heading: #023b95;
  --color-prettylights-syntax-markup-italic: #0e1116;
  --color-prettylights-syntax-markup-bold: #0e1116;
  --color-prettylights-syntax-markup-deleted-text: #6e011a;
  --color-prettylights-syntax-markup-deleted-bg: #fff0ee;
  --color-prettylights-syntax-markup-inserted-text: #024c1a;
  --color-prettylights-syntax-markup-inserted-bg: #d2fedb;
  --color-prettylights-syntax-markup-changed-text: #702c00;
  --color-prettylights-syntax-markup-changed-bg: #ffc67b;
  --color-prettylights-syntax-markup-ignored-text: #e7ecf0;
  --color-prettylights-syntax-markup-ignored-bg: #023b95;
  --color-prettylights-syntax-meta-diff-range: #622cbc;
  --color-prettylights-syntax-brackethighlighter-angle: #4b535d;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #88929d;
  --color-prettylights-syntax-constant-other-reference-link: #032563;
  --color-fg-default: #0e1116;
  --color-fg-muted: #0e1116;
  --color-fg-subtle: #66707b;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #e7ecf0;
  --color-border-default: #20252c;
  --color-border-muted: #88929d;
  --color-neutral-muted: rgba(172,182,192,0.2);
  --color-accent-fg: #0349b4;
  --color-accent-emphasis: #0349b4;
  --color-attention-subtle: #fcf7be;
  --color-danger-fg: #d1242f;
}
}

[data-color-mode=light][data-light-theme=dark],
[data-color-mode=dark][data-dark-theme=dark],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=dark],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=dark] {
  /*dark*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #7ee787;
  --color-prettylights-syntax-keyword: #ff7b72;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #ffa657;
  --color-prettylights-syntax-brackethighlighter-unmatched: #f85149;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #8e1519;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #b62324;
  --color-prettylights-syntax-string-regexp: #7ee787;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffdcd7;
  --color-prettylights-syntax-markup-deleted-bg: #67060c;
  --color-prettylights-syntax-markup-inserted-text: #aff5b4;
  --color-prettylights-syntax-markup-inserted-bg: #033a16;
  --color-prettylights-syntax-markup-changed-text: #ffdfb6;
  --color-prettylights-syntax-markup-changed-bg: #5a1e02;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #e6edf3;
  --color-fg-muted: #7d8590;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #2f81f7;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #f85149;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=dark] {
  /*dark*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #7ee787;
  --color-prettylights-syntax-keyword: #ff7b72;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #ffa657;
  --color-prettylights-syntax-brackethighlighter-unmatched: #f85149;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #8e1519;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #b62324;
  --color-prettylights-syntax-string-regexp: #7ee787;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffdcd7;
  --color-prettylights-syntax-markup-deleted-bg: #67060c;
  --color-prettylights-syntax-markup-inserted-text: #aff5b4;
  --color-prettylights-syntax-markup-inserted-bg: #033a16;
  --color-prettylights-syntax-markup-changed-text: #ffdfb6;
  --color-prettylights-syntax-markup-changed-bg: #5a1e02;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #e6edf3;
  --color-fg-muted: #7d8590;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #2f81f7;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #f85149;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=dark] {
  /*dark*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #7ee787;
  --color-prettylights-syntax-keyword: #ff7b72;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #ffa657;
  --color-prettylights-syntax-brackethighlighter-unmatched: #f85149;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #8e1519;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #b62324;
  --color-prettylights-syntax-string-regexp: #7ee787;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffdcd7;
  --color-prettylights-syntax-markup-deleted-bg: #67060c;
  --color-prettylights-syntax-markup-inserted-text: #aff5b4;
  --color-prettylights-syntax-markup-inserted-bg: #033a16;
  --color-prettylights-syntax-markup-changed-text: #ffdfb6;
  --color-prettylights-syntax-markup-changed-bg: #5a1e02;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #e6edf3;
  --color-fg-muted: #7d8590;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #2f81f7;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #f85149;
}
}

[data-color-mode=light][data-light-theme=dark_dimmed],
[data-color-mode=dark][data-dark-theme=dark_dimmed],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=dark_dimmed],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=dark_dimmed] {
  /*dark_dimmed*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #768390;
  --color-prettylights-syntax-constant: #6cb6ff;
  --color-prettylights-syntax-entity: #dcbdfb;
  --color-prettylights-syntax-storage-modifier-import: #adbac7;
  --color-prettylights-syntax-entity-tag: #8ddb8c;
  --color-prettylights-syntax-keyword: #f47067;
  --color-prettylights-syntax-string: #96d0ff;
  --color-prettylights-syntax-variable: #f69d50;
  --color-prettylights-syntax-brackethighlighter-unmatched: #e5534b;
  --color-prettylights-syntax-invalid-illegal-text: #cdd9e5;
  --color-prettylights-syntax-invalid-illegal-bg: #922323;
  --color-prettylights-syntax-carriage-return-text: #cdd9e5;
  --color-prettylights-syntax-carriage-return-bg: #ad2e2c;
  --color-prettylights-syntax-string-regexp: #8ddb8c;
  --color-prettylights-syntax-markup-list: #eac55f;
  --color-prettylights-syntax-markup-heading: #316dca;
  --color-prettylights-syntax-markup-italic: #adbac7;
  --color-prettylights-syntax-markup-bold: #adbac7;
  --color-prettylights-syntax-markup-deleted-text: #ffd8d3;
  --color-prettylights-syntax-markup-deleted-bg: #78191b;
  --color-prettylights-syntax-markup-inserted-text: #b4f1b4;
  --color-prettylights-syntax-markup-inserted-bg: #1b4721;
  --color-prettylights-syntax-markup-changed-text: #ffddb0;
  --color-prettylights-syntax-markup-changed-bg: #682d0f;
  --color-prettylights-syntax-markup-ignored-text: #adbac7;
  --color-prettylights-syntax-markup-ignored-bg: #255ab2;
  --color-prettylights-syntax-meta-diff-range: #dcbdfb;
  --color-prettylights-syntax-brackethighlighter-angle: #768390;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #545d68;
  --color-prettylights-syntax-constant-other-reference-link: #96d0ff;
  --color-fg-default: #adbac7;
  --color-fg-muted: #768390;
  --color-fg-subtle: #636e7b;
  --color-canvas-default: #22272e;
  --color-canvas-subtle: #2d333b;
  --color-border-default: #444c56;
  --color-border-muted: #373e47;
  --color-neutral-muted: rgba(99,110,123,0.4);
  --color-accent-fg: #539bf5;
  --color-accent-emphasis: #316dca;
  --color-attention-subtle: rgba(174,124,20,0.15);
  --color-danger-fg: #e5534b;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=dark_dimmed] {
  /*dark_dimmed*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #768390;
  --color-prettylights-syntax-constant: #6cb6ff;
  --color-prettylights-syntax-entity: #dcbdfb;
  --color-prettylights-syntax-storage-modifier-import: #adbac7;
  --color-prettylights-syntax-entity-tag: #8ddb8c;
  --color-prettylights-syntax-keyword: #f47067;
  --color-prettylights-syntax-string: #96d0ff;
  --color-prettylights-syntax-variable: #f69d50;
  --color-prettylights-syntax-brackethighlighter-unmatched: #e5534b;
  --color-prettylights-syntax-invalid-illegal-text: #cdd9e5;
  --color-prettylights-syntax-invalid-illegal-bg: #922323;
  --color-prettylights-syntax-carriage-return-text: #cdd9e5;
  --color-prettylights-syntax-carriage-return-bg: #ad2e2c;
  --color-prettylights-syntax-string-regexp: #8ddb8c;
  --color-prettylights-syntax-markup-list: #eac55f;
  --color-prettylights-syntax-markup-heading: #316dca;
  --color-prettylights-syntax-markup-italic: #adbac7;
  --color-prettylights-syntax-markup-bold: #adbac7;
  --color-prettylights-syntax-markup-deleted-text: #ffd8d3;
  --color-prettylights-syntax-markup-deleted-bg: #78191b;
  --color-prettylights-syntax-markup-inserted-text: #b4f1b4;
  --color-prettylights-syntax-markup-inserted-bg: #1b4721;
  --color-prettylights-syntax-markup-changed-text: #ffddb0;
  --color-prettylights-syntax-markup-changed-bg: #682d0f;
  --color-prettylights-syntax-markup-ignored-text: #adbac7;
  --color-prettylights-syntax-markup-ignored-bg: #255ab2;
  --color-prettylights-syntax-meta-diff-range: #dcbdfb;
  --color-prettylights-syntax-brackethighlighter-angle: #768390;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #545d68;
  --color-prettylights-syntax-constant-other-reference-link: #96d0ff;
  --color-fg-default: #adbac7;
  --color-fg-muted: #768390;
  --color-fg-subtle: #636e7b;
  --color-canvas-default: #22272e;
  --color-canvas-subtle: #2d333b;
  --color-border-default: #444c56;
  --color-border-muted: #373e47;
  --color-neutral-muted: rgba(99,110,123,0.4);
  --color-accent-fg: #539bf5;
  --color-accent-emphasis: #316dca;
  --color-attention-subtle: rgba(174,124,20,0.15);
  --color-danger-fg: #e5534b;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=dark_dimmed] {
  /*dark_dimmed*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #768390;
  --color-prettylights-syntax-constant: #6cb6ff;
  --color-prettylights-syntax-entity: #dcbdfb;
  --color-prettylights-syntax-storage-modifier-import: #adbac7;
  --color-prettylights-syntax-entity-tag: #8ddb8c;
  --color-prettylights-syntax-keyword: #f47067;
  --color-prettylights-syntax-string: #96d0ff;
  --color-prettylights-syntax-variable: #f69d50;
  --color-prettylights-syntax-brackethighlighter-unmatched: #e5534b;
  --color-prettylights-syntax-invalid-illegal-text: #cdd9e5;
  --color-prettylights-syntax-invalid-illegal-bg: #922323;
  --color-prettylights-syntax-carriage-return-text: #cdd9e5;
  --color-prettylights-syntax-carriage-return-bg: #ad2e2c;
  --color-prettylights-syntax-string-regexp: #8ddb8c;
  --color-prettylights-syntax-markup-list: #eac55f;
  --color-prettylights-syntax-markup-heading: #316dca;
  --color-prettylights-syntax-markup-italic: #adbac7;
  --color-prettylights-syntax-markup-bold: #adbac7;
  --color-prettylights-syntax-markup-deleted-text: #ffd8d3;
  --color-prettylights-syntax-markup-deleted-bg: #78191b;
  --color-prettylights-syntax-markup-inserted-text: #b4f1b4;
  --color-prettylights-syntax-markup-inserted-bg: #1b4721;
  --color-prettylights-syntax-markup-changed-text: #ffddb0;
  --color-prettylights-syntax-markup-changed-bg: #682d0f;
  --color-prettylights-syntax-markup-ignored-text: #adbac7;
  --color-prettylights-syntax-markup-ignored-bg: #255ab2;
  --color-prettylights-syntax-meta-diff-range: #dcbdfb;
  --color-prettylights-syntax-brackethighlighter-angle: #768390;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #545d68;
  --color-prettylights-syntax-constant-other-reference-link: #96d0ff;
  --color-fg-default: #adbac7;
  --color-fg-muted: #768390;
  --color-fg-subtle: #636e7b;
  --color-canvas-default: #22272e;
  --color-canvas-subtle: #2d333b;
  --color-border-default: #444c56;
  --color-border-muted: #373e47;
  --color-neutral-muted: rgba(99,110,123,0.4);
  --color-accent-fg: #539bf5;
  --color-accent-emphasis: #316dca;
  --color-attention-subtle: rgba(174,124,20,0.15);
  --color-danger-fg: #e5534b;
}
}

[data-color-mode=light][data-light-theme=dark_colorblind],
[data-color-mode=dark][data-dark-theme=dark_colorblind],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=dark_colorblind],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=dark_colorblind] {
  /*dark_colorblind*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #a5d6ff;
  --color-prettylights-syntax-keyword: #ec8e2c;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #fdac54;
  --color-prettylights-syntax-brackethighlighter-unmatched: #d47616;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #6c3906;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #914d04;
  --color-prettylights-syntax-string-regexp: #a5d6ff;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffe2bb;
  --color-prettylights-syntax-markup-deleted-bg: #4e2906;
  --color-prettylights-syntax-markup-inserted-text: #cae8ff;
  --color-prettylights-syntax-markup-inserted-bg: #0c2d6b;
  --color-prettylights-syntax-markup-changed-text: #ffe2bb;
  --color-prettylights-syntax-markup-changed-bg: #4e2906;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #c9d1d9;
  --color-fg-muted: #8b949e;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #58a6ff;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #d47616;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=dark_colorblind] {
  /*dark_colorblind*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #a5d6ff;
  --color-prettylights-syntax-keyword: #ec8e2c;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #fdac54;
  --color-prettylights-syntax-brackethighlighter-unmatched: #d47616;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #6c3906;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #914d04;
  --color-prettylights-syntax-string-regexp: #a5d6ff;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffe2bb;
  --color-prettylights-syntax-markup-deleted-bg: #4e2906;
  --color-prettylights-syntax-markup-inserted-text: #cae8ff;
  --color-prettylights-syntax-markup-inserted-bg: #0c2d6b;
  --color-prettylights-syntax-markup-changed-text: #ffe2bb;
  --color-prettylights-syntax-markup-changed-bg: #4e2906;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #c9d1d9;
  --color-fg-muted: #8b949e;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #58a6ff;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #d47616;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=dark_colorblind] {
  /*dark_colorblind*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #a5d6ff;
  --color-prettylights-syntax-keyword: #ec8e2c;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #fdac54;
  --color-prettylights-syntax-brackethighlighter-unmatched: #d47616;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #6c3906;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #914d04;
  --color-prettylights-syntax-string-regexp: #a5d6ff;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffe2bb;
  --color-prettylights-syntax-markup-deleted-bg: #4e2906;
  --color-prettylights-syntax-markup-inserted-text: #cae8ff;
  --color-prettylights-syntax-markup-inserted-bg: #0c2d6b;
  --color-prettylights-syntax-markup-changed-text: #ffe2bb;
  --color-prettylights-syntax-markup-changed-bg: #4e2906;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #c9d1d9;
  --color-fg-muted: #8b949e;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #58a6ff;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #d47616;
}
}

[data-color-mode=light][data-light-theme=dark_tritanopia],
[data-color-mode=dark][data-dark-theme=dark_tritanopia],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=dark_tritanopia],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=dark_tritanopia] {
  /*dark_tritanopia*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #a5d6ff;
  --color-prettylights-syntax-keyword: #ff7b72;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #ffa198;
  --color-prettylights-syntax-brackethighlighter-unmatched: #f85149;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #8e1519;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #b62324;
  --color-prettylights-syntax-string-regexp: #a5d6ff;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffdcd7;
  --color-prettylights-syntax-markup-deleted-bg: #67060c;
  --color-prettylights-syntax-markup-inserted-text: #cae8ff;
  --color-prettylights-syntax-markup-inserted-bg: #0c2d6b;
  --color-prettylights-syntax-markup-changed-text: #ffdcd7;
  --color-prettylights-syntax-markup-changed-bg: #67060c;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #c9d1d9;
  --color-fg-muted: #8b949e;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #58a6ff;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #f85149;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=dark_tritanopia] {
  /*dark_tritanopia*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #a5d6ff;
  --color-prettylights-syntax-keyword: #ff7b72;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #ffa198;
  --color-prettylights-syntax-brackethighlighter-unmatched: #f85149;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #8e1519;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #b62324;
  --color-prettylights-syntax-string-regexp: #a5d6ff;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffdcd7;
  --color-prettylights-syntax-markup-deleted-bg: #67060c;
  --color-prettylights-syntax-markup-inserted-text: #cae8ff;
  --color-prettylights-syntax-markup-inserted-bg: #0c2d6b;
  --color-prettylights-syntax-markup-changed-text: #ffdcd7;
  --color-prettylights-syntax-markup-changed-bg: #67060c;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #c9d1d9;
  --color-fg-muted: #8b949e;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #58a6ff;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #f85149;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=dark_tritanopia] {
  /*dark_tritanopia*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #a5d6ff;
  --color-prettylights-syntax-keyword: #ff7b72;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #ffa198;
  --color-prettylights-syntax-brackethighlighter-unmatched: #f85149;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #8e1519;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #b62324;
  --color-prettylights-syntax-string-regexp: #a5d6ff;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffdcd7;
  --color-prettylights-syntax-markup-deleted-bg: #67060c;
  --color-prettylights-syntax-markup-inserted-text: #cae8ff;
  --color-prettylights-syntax-markup-inserted-bg: #0c2d6b;
  --color-prettylights-syntax-markup-changed-text: #ffdcd7;
  --color-prettylights-syntax-markup-changed-bg: #67060c;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #c9d1d9;
  --color-fg-muted: #8b949e;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #58a6ff;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #f85149;
}
}

[data-color-mode=light][data-light-theme=dark_high_contrast],
[data-color-mode=dark][data-dark-theme=dark_high_contrast],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=dark_high_contrast],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=dark_high_contrast] {
  /*dark_high_contrast*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #bdc4cc;
  --color-prettylights-syntax-constant: #91cbff;
  --color-prettylights-syntax-entity: #dbb7ff;
  --color-prettylights-syntax-storage-modifier-import: #f0f3f6;
  --color-prettylights-syntax-entity-tag: #72f088;
  --color-prettylights-syntax-keyword: #ff9492;
  --color-prettylights-syntax-string: #addcff;
  --color-prettylights-syntax-variable: #ffb757;
  --color-prettylights-syntax-brackethighlighter-unmatched: #ff6a69;
  --color-prettylights-syntax-invalid-illegal-text: #ffffff;
  --color-prettylights-syntax-invalid-illegal-bg: #e82a2f;
  --color-prettylights-syntax-carriage-return-text: #ffffff;
  --color-prettylights-syntax-carriage-return-bg: #ff4445;
  --color-prettylights-syntax-string-regexp: #72f088;
  --color-prettylights-syntax-markup-list: #fbd669;
  --color-prettylights-syntax-markup-heading: #409eff;
  --color-prettylights-syntax-markup-italic: #f0f3f6;
  --color-prettylights-syntax-markup-bold: #f0f3f6;
  --color-prettylights-syntax-markup-deleted-text: #ffdedb;
  --color-prettylights-syntax-markup-deleted-bg: #cc1421;
  --color-prettylights-syntax-markup-inserted-text: #acf7b6;
  --color-prettylights-syntax-markup-inserted-bg: #007728;
  --color-prettylights-syntax-markup-changed-text: #ffe1b4;
  --color-prettylights-syntax-markup-changed-bg: #a74c00;
  --color-prettylights-syntax-markup-ignored-text: #f0f3f6;
  --color-prettylights-syntax-markup-ignored-bg: #318bf8;
  --color-prettylights-syntax-meta-diff-range: #dbb7ff;
  --color-prettylights-syntax-brackethighlighter-angle: #bdc4cc;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #7a828e;
  --color-prettylights-syntax-constant-other-reference-link: #addcff;
  --color-fg-default: #f0f3f6;
  --color-fg-muted: #f0f3f6;
  --color-fg-subtle: #9ea7b3;
  --color-canvas-default: #0a0c10;
  --color-canvas-subtle: #272b33;
  --color-border-default: #7a828e;
  --color-border-muted: #7a828e;
  --color-neutral-muted: rgba(158,167,179,0.4);
  --color-accent-fg: #71b7ff;
  --color-accent-emphasis: #409eff;
  --color-attention-subtle: rgba(224,155,19,0.15);
  --color-danger-fg: #ff6a69;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=dark_high_contrast] {
  /*dark_high_contrast*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #bdc4cc;
  --color-prettylights-syntax-constant: #91cbff;
  --color-prettylights-syntax-entity: #dbb7ff;
  --color-prettylights-syntax-storage-modifier-import: #f0f3f6;
  --color-prettylights-syntax-entity-tag: #72f088;
  --color-prettylights-syntax-keyword: #ff9492;
  --color-prettylights-syntax-string: #addcff;
  --color-prettylights-syntax-variable: #ffb757;
  --color-prettylights-syntax-brackethighlighter-unmatched: #ff6a69;
  --color-prettylights-syntax-invalid-illegal-text: #ffffff;
  --color-prettylights-syntax-invalid-illegal-bg: #e82a2f;
  --color-prettylights-syntax-carriage-return-text: #ffffff;
  --color-prettylights-syntax-carriage-return-bg: #ff4445;
  --color-prettylights-syntax-string-regexp: #72f088;
  --color-prettylights-syntax-markup-list: #fbd669;
  --color-prettylights-syntax-markup-heading: #409eff;
  --color-prettylights-syntax-markup-italic: #f0f3f6;
  --color-prettylights-syntax-markup-bold: #f0f3f6;
  --color-prettylights-syntax-markup-deleted-text: #ffdedb;
  --color-prettylights-syntax-markup-deleted-bg: #cc1421;
  --color-prettylights-syntax-markup-inserted-text: #acf7b6;
  --color-prettylights-syntax-markup-inserted-bg: #007728;
  --color-prettylights-syntax-markup-changed-text: #ffe1b4;
  --color-prettylights-syntax-markup-changed-bg: #a74c00;
  --color-prettylights-syntax-markup-ignored-text: #f0f3f6;
  --color-prettylights-syntax-markup-ignored-bg: #318bf8;
  --color-prettylights-syntax-meta-diff-range: #dbb7ff;
  --color-prettylights-syntax-brackethighlighter-angle: #bdc4cc;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #7a828e;
  --color-prettylights-syntax-constant-other-reference-link: #addcff;
  --color-fg-default: #f0f3f6;
  --color-fg-muted: #f0f3f6;
  --color-fg-subtle: #9ea7b3;
  --color-canvas-default: #0a0c10;
  --color-canvas-subtle: #272b33;
  --color-border-default: #7a828e;
  --color-border-muted: #7a828e;
  --color-neutral-muted: rgba(158,167,179,0.4);
  --color-accent-fg: #71b7ff;
  --color-accent-emphasis: #409eff;
  --color-attention-subtle: rgba(224,155,19,0.15);
  --color-danger-fg: #ff6a69;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=dark_high_contrast] {
  /*dark_high_contrast*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #bdc4cc;
  --color-prettylights-syntax-constant: #91cbff;
  --color-prettylights-syntax-entity: #dbb7ff;
  --color-prettylights-syntax-storage-modifier-import: #f0f3f6;
  --color-prettylights-syntax-entity-tag: #72f088;
  --color-prettylights-syntax-keyword: #ff9492;
  --color-prettylights-syntax-string: #addcff;
  --color-prettylights-syntax-variable: #ffb757;
  --color-prettylights-syntax-brackethighlighter-unmatched: #ff6a69;
  --color-prettylights-syntax-invalid-illegal-text: #ffffff;
  --color-prettylights-syntax-invalid-illegal-bg: #e82a2f;
  --color-prettylights-syntax-carriage-return-text: #ffffff;
  --color-prettylights-syntax-carriage-return-bg: #ff4445;
  --color-prettylights-syntax-string-regexp: #72f088;
  --color-prettylights-syntax-markup-list: #fbd669;
  --color-prettylights-syntax-markup-heading: #409eff;
  --color-prettylights-syntax-markup-italic: #f0f3f6;
  --color-prettylights-syntax-markup-bold: #f0f3f6;
  --color-prettylights-syntax-markup-deleted-text: #ffdedb;
  --color-prettylights-syntax-markup-deleted-bg: #cc1421;
  --color-prettylights-syntax-markup-inserted-text: #acf7b6;
  --color-prettylights-syntax-markup-inserted-bg: #007728;
  --color-prettylights-syntax-markup-changed-text: #ffe1b4;
  --color-prettylights-syntax-markup-changed-bg: #a74c00;
  --color-prettylights-syntax-markup-ignored-text: #f0f3f6;
  --color-prettylights-syntax-markup-ignored-bg: #318bf8;
  --color-prettylights-syntax-meta-diff-range: #dbb7ff;
  --color-prettylights-syntax-brackethighlighter-angle: #bdc4cc;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #7a828e;
  --color-prettylights-syntax-constant-other-reference-link: #addcff;
  --color-fg-default: #f0f3f6;
  --color-fg-muted: #f0f3f6;
  --color-fg-subtle: #9ea7b3;
  --color-canvas-default: #0a0c10;
  --color-canvas-subtle: #272b33;
  --color-border-default: #7a828e;
  --color-border-muted: #7a828e;
  --color-neutral-muted: rgba(158,167,179,0.4);
  --color-accent-fg: #71b7ff;
  --color-accent-emphasis: #409eff;
  --color-attention-subtle: rgba(224,155,19,0.15);
  --color-danger-fg: #ff6a69;
}
}

/*!
  Theme: GitHub
  Description: Highlight-js port of github.com theme
  Author: github.com
  Maintainer: @SNDST00M, @mjbvz
  Updated: 2021-12-08
*/
.markdown-body pre code.hljs {
  display: block;
  overflow-x: auto;
  padding: 16px;
}

.markdown-body code.hljs {
  padding: 3px 5px;
}

/*!
  Theme: GitHub
  Description: Theme as seen on github.com
  Author: github.com
  Maintainer: @Hirse
  Updated: 2021-05-15

  Outdated base version: https://github.com/primer/github-syntax-dark
  Current colors taken from GitHub's CSS
*/
.markdown-body .hljs {
  color: var(--color-fg-default);
  background: var(--color-canvas-subtle);
}

.markdown-body .hljs-doctag,
.markdown-body .hljs-keyword,
.markdown-body .hljs-meta .hljs-keyword,
.markdown-body .hljs-template-tag,
.markdown-body .hljs-template-variable,
.markdown-body .hljs-type,
.markdown-body .hljs-variable.language_ {
  color: var(--color-prettylights-syntax-keyword);
}

.markdown-body .hljs-title,
.markdown-body .hljs-title.class_,
.markdown-body .hljs-title.class_.inherited__,
.markdown-body .hljs-title.function_ {
  color: var(--color-prettylights-syntax-entity);
}

.markdown-body .hljs-attr,
.markdown-body .hljs-attribute,
.markdown-body .hljs-literal,
.markdown-body .hljs-meta,
.markdown-body .hljs-number,
.markdown-body .hljs-operator,
.markdown-body .hljs-selector-attr,
.markdown-body .hljs-selector-class,
.markdown-body .hljs-selector-id,
.markdown-body .hljs-variable {
  color: var(--color-prettylights-syntax-constant);
}

.markdown-body .hljs-meta .hljs-string,
.markdown-body .hljs-regexp,
.markdown-body .hljs-string {
  color: var(--color-prettylights-syntax-string);
}

.markdown-body .hljs-built_in,
.markdown-body .hljs-symbol {
  color: var(--color-prettylights-syntax-variable);
}

.markdown-body .hljs-code,
.markdown-body .hljs-comment,
.markdown-body .hljs-formula {
  color: var(--color-prettylights-syntax-comment);
}

.markdown-body .hljs-name,
.markdown-body .hljs-quote,
.markdown-body .hljs-selector-pseudo,
.markdown-body .hljs-selector-tag {
  color: var(--color-prettylights-syntax-entity-tag);
}

.markdown-body .hljs-subst {
  color: var(--color-prettylights-syntax-constant);
}

.markdown-body .hljs-section {
  color: var(--color-prettylights-syntax-markup-heading);
  font-weight: bold;
}

.markdown-body .hljs-bullet {
  color: var(--color-prettylights-syntax-markup-list);
}

.markdown-body .hljs-emphasis {
  color: var(--color-prettylights-syntax-constant);
  font-style: italic;
}

.markdown-body .hljs-strong {
  color: var(--color-prettylights-syntax-constant);
  font-weight: bold;
}

.markdown-body .hljs-addition {
  color: var(--color-prettylights-syntax-markup-inserted-text);
  background-color: var(--color-prettylights-syntax-markup-inserted-bg);
}

.markdown-body .hljs-deletion {
  color: var(--color-prettylights-syntax-markup-deleted-text);
  background-color: var(--color-prettylights-syntax-markup-deleted-bg);
}

</style>
            
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <div
            class="github-markdown-body"
            data-color-mode="auto"
            data-light-theme="light"
            data-dark-theme="dark"
        >
            <div class="github-markdown-content"><h1 id="3hafta">3.Hafta</h1>
<h2 id="iindekiler">indekiler</h2>
<ul>
<li><a href="#3hafta">3.Hafta</a>
<ul>
<li><a href="#i%CC%87%C3%A7indekiler">indekiler</a></li>
<li><a href="#perfect-forwarding">Perfect Forwarding</a>
<ul>
<li><a href="#auto-"><code>auto &amp;&amp;</code></a>
<ul>
<li><a href="#return-value-perfect-passing">Return value perfect passing</a></li>
<li><a href="#perfect-returning">Perfect Returning</a>
<ul>
<li><a href="#decltypeauto">decltype(auto)</a></li>
</ul>
</li>
<li><a href="#reference-qualifier">Reference Qualifier</a></li>
</ul>
</li>
<li><a href="#universal-referans-olmayan-fakat-%C3%B6yle-g%C3%B6z%C3%BCken-senaryolar">Universal Referans Olmayan Fakat yle Gzken Senaryolar</a></li>
</ul>
</li>
<li><a href="#move-only-types">Move Only Types</a></li>
<li><a href="#stlde-move-semantics-ve-perfect-forwarding">STL'de Move Semantics ve Perfect Forwarding</a>
<ul>
<li><a href="#algoritmalar%C4%B1">Algoritmalar</a></li>
<li><a href="#remove--remove_if--unique">remove &amp; remove_if &amp; unique</a></li>
<li><a href="#emplace">Emplace</a></li>
<li><a href="#copy_backward-algoritmas%C4%B1">Copy_backward algoritmas</a></li>
<li><a href="#move_backward-algoritmas%C4%B1">Move_backward algoritmas</a></li>
<li><a href="#move-iterat%C3%B6r-adapt%C3%B6r%C3%BC">Move Iteratr Adaptr</a></li>
</ul>
</li>
<li><a href="#literal-operator-functions">Literal Operator Functions</a>
<ul>
<li><a href="#userdefined-literal">Userdefined Literal</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="perfect-forwarding">Perfect Forwarding</h2>
<p><code>std::forward&lt;&gt;</code> kullanmn incelemitik.</p>
<p>Lambda ifadelerinde trn elimizde olmadndan bahsetmitik.</p>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">auto</span> fn = [](<span class="hljs-keyword">auto</span>&amp;&amp; t){
        std::forward&lt;<span class="hljs-keyword">decltype</span>(t)&gt;(t);
    };
    <span class="hljs-comment">// C++20 ile</span>
    <span class="hljs-keyword">auto</span> fn1 = []&lt;<span class="hljs-keyword">typename</span> T&gt;(T &amp;&amp; t){   
        std::forward&lt;T&gt;(t);
    };
}
</code></pre>
<p>Ksaltml template sentaks da eklendi</p>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T x)</span></span>;
<span class="hljs-comment">//C++20 ile aadaki gibi yazlabilir.</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> &amp;&amp;x)</span></span>;
</code></pre>
<ul>
<li>Universasl reference' sadece perfect forwarding iin kullanmak zorudnda deiliz ve terimde de bir uyumazlk oluuyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">navigate</span><span class="hljs-params">(std::string iterator beg, std::string::iterator end)</span>
</span>{
    std::cout&lt;&lt; <span class="hljs-string">&quot;non const semantics on the passed range \n&quot;</span>;
}
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">navigate</span><span class="hljs-params">(std::string::const_iterator beg, std::string::const_iterator end)</span>
</span>{
    std::cout&lt;&lt; <span class="hljs-string">&quot;const semantics on the passed range \n&quot;</span>;
}
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process_contianer</span><span class="hljs-params">(T &amp;&amp;t)</span>
</span>{
    <span class="hljs-built_in">navigate</span>(std::<span class="hljs-built_in">begin</span>(t), std::<span class="hljs-built_in">end</span>(t));
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    std::string name{<span class="hljs-string">&quot;mutable test&quot;</span>}
    std::string <span class="hljs-type">const</span> cname{<span class="hljs-string">&quot;imutable test&quot;</span>};    
    <span class="hljs-built_in">process_contianer</span>(name); <span class="hljs-comment">// non const semantics on the passed range</span>
    <span class="hljs-built_in">process_contianer</span>(cname); <span class="hljs-comment">// non const semantics on the passed range</span>
    <span class="hljs-built_in">process_contianer</span>(std::string{<span class="hljs-string">&quot;temporary&quot;</span>}); <span class="hljs-comment">// non const semantics on the passed range</span>
    <span class="hljs-built_in">process_contianer</span>(std::<span class="hljs-built_in">move</span>(name)); <span class="hljs-comment">// non const semantics on the passed range</span>
    <span class="hljs-built_in">process_contianer</span>(std::<span class="hljs-built_in">move</span>(cname)); <span class="hljs-comment">// non const semantics on the passed range</span>
}
</code></pre>
<p>navigate fonksiyonun 2tane overloadi var birinin parametreleri const dierininki const olmayan iterator. <code>process_container</code> iin de const'uluk korunuyor ve ar buna gre yaplyor.</p>
<p>Kendimiz de constlua bal generic bir fonksiyonda oluturabiliriz.</p>
<pre><code class="language-c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T&amp;&amp; )</span>
</span>{
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::is_const_v&lt;std::<span class="hljs-type">remove_reference_t</span>&lt;T&gt;&gt;)</span>
    </span>{
        std::cout&lt;&lt; <span class="hljs-string">&quot;const &quot;</span>;
    }
    <span class="hljs-keyword">else</span>
    {
        std::cout&lt;&lt; <span class="hljs-string">&quot;non const &quot;</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::is_lvalue_reference_v&lt;T&gt;)</span>
    </span>{
        std::cout&lt;&lt; <span class="hljs-string">&quot;lvalue\n&quot;</span>;
    }
    <span class="hljs-keyword">else</span>
    {
        std::cout&lt;&lt; <span class="hljs-string">&quot;rvalue\n&quot;</span>;
    }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span> {};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    std::string name{<span class="hljs-string">&quot;non const test&quot;</span>}
    <span class="hljs-built_in">func</span>(name); <span class="hljs-comment">// non const</span>
    std::string cname{<span class="hljs-string">&quot;const test&quot;</span>}
    <span class="hljs-built_in">func</span>(cname); <span class="hljs-comment">// const</span>

    <span class="hljs-built_in">func</span>(Myclass{}); <span class="hljs-comment">// non const</span>
    Myclass c;
    <span class="hljs-built_in">func</span>(c); <span class="hljs-comment">// non const</span>
    <span class="hljs-built_in">func</span>(std::<span class="hljs-built_in">move</span>(c)); <span class="hljs-comment">// non const</span>
}
</code></pre>
<blockquote>
<p>Buradaki if constexpre run time'a deil compile time ile alakal bir fonksiyon.</p>
</blockquote>
<p>Universal reference parametre birden fazla yerde kullanlabiliyor ve burada value-category dependent code yazabiliyoruz. type_Traits ktphanesi ile T trnn hakkndaki bilgileri sorgulayabiliyoruz</p>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T,T)</span></span>;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">// burada sentaks hatas yok</span>
    <span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2.</span>); <span class="hljs-comment">// Sentaks hatas</span>
    <span class="hljs-built_in">func</span>(<span class="hljs-string">&quot;ali&quot;</span>,<span class="hljs-string">&quot;ayse&quot;</span>); <span class="hljs-comment">//sentaks hatas deil </span>
}
</code></pre>
<p>Derleyici asndan ilk argmana baklrsa T int, ikinci argmana baklrsa T double. Burada sentaks hatas oluuyor.</p>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T&amp;,T&amp;)</span></span>;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">func</span>(<span class="hljs-string">&quot;ali&quot;</span>,<span class="hljs-string">&quot;ayse&quot;</span>); <span class="hljs-comment">//SENTAKS HATASI</span>
}
</code></pre>
<p>Burada ayn sentaks hatas oluuyor nk karm <code>const char [4]</code>, <code>const char[5]</code> olarak yaplyor.</p>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(std::vector&lt;T&gt; &amp;vec, T &amp;&amp;val)</span>
</span>{
    vec.<span class="hljs-built_in">push_back</span>(std::forward&lt;T&gt;(val));
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    std::vector&lt;std::string&gt; vec;
    std:string name;
    <span class="hljs-built_in">insert</span>(vec, name); <span class="hljs-comment">// SENTAKS HATASI</span>
}
</code></pre>
<p>Bu sentaks hatasnn nedeni 1.parametrenin karm T'nin string olmas zerine, 2.parametre iinse T'nin karm T&amp; olarak ve string &amp; olarak yaplyor. Bu yzden hata oluuyor.</p>
<ul>
<li>remove_reference kullanarak bu sorunu zebiliriz.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(std::vector&lt;std::<span class="hljs-type">remove_referednce_t</span>&lt;T&gt;&gt; &amp;vec, T &amp;&amp;val)</span>
</span>{
    vec.<span class="hljs-built_in">push_back</span>(std::forward&lt;T&gt;(val));
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    std::vector&lt;std::string&gt; vec;
    std:string name;
    <span class="hljs-built_in">insert</span>(vec, name);
}
</code></pre>
<ul>
<li>2 tane template parametre kullanarak</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElemType, <span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(std::vector&lt;ElemType&gt; &amp;vec, T &amp;&amp;val)</span>
</span>{
    vec.<span class="hljs-built_in">push_back</span>(std::forward&lt;T&gt;(val));
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    std::vector&lt;std::string&gt; vec;
    std:string name;
    <span class="hljs-built_in">insert</span>(vec, name);
}
</code></pre>
<ul>
<li>Ya da container trn template parametresi olarak alabiliriz.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Container, <span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Container &amp;vec, T &amp;&amp;val)</span>
</span>{
    vec.<span class="hljs-built_in">push_back</span>(std::forward&lt;T&gt;(val));
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    std::vector&lt;std::string&gt; vec;
    std:string name;
    <span class="hljs-built_in">insert</span>(vec, name);
}
</code></pre>
<h3 id="auto-"><code>auto &amp;&amp;</code></h3>
<ul>
<li>auto &amp;&amp; ile universal reference' kullanabiliriz.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span> {}; 

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Myclass m;
    <span class="hljs-type">const</span> Myclass cm;
    <span class="hljs-keyword">auto</span> &amp;&amp;r1 = Myclass{}; <span class="hljs-comment">// Myclass = </span>
    <span class="hljs-keyword">auto</span> &amp;&amp;r2 = m; <span class="hljs-comment">// auto = Myclass &amp; reference collapsing ile Myclass &amp; oluyor</span>
    <span class="hljs-keyword">auto</span> &amp;&amp;r3 = cm;
    <span class="hljs-keyword">auto</span> &amp;&amp;r4 = std::<span class="hljs-built_in">move</span>(m);
    <span class="hljs-keyword">auto</span> &amp;&amp;r5 = std::<span class="hljs-built_in">move</span>(cm);
}
</code></pre>
<blockquote>
<p>fonksiyonun parametresi T'tr iin yaplan karm nasl yaplyorsa, auto iin ayaplan karm da ayn ekilde yaplyor. Buradaki karm <code>auto</code> iin yaplyor. Template karm da T'tr iin karm yapyor.</p>
</blockquote>
<p>Kullanlmasnn gerekli olduu senaryolar:</p>
<ul>
<li>Forwarding reference olarak kullanabiliriz.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span> {};
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> Myclass &amp;)</span>
</span>{
    std::cout&lt;&lt; <span class="hljs-string">&quot;foo(const Myclass &amp;)\n&quot;</span>;
}
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(Myclass &amp;&amp;)</span>
</span>{
    std::cout&lt;&lt; <span class="hljs-string">&quot;foo(Myclass &amp;&amp;)\n&quot;</span>;
}
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(Myclass &amp;)</span>
</span>{
    std::cout&lt;&lt; <span class="hljs-string">&quot;foo(Myclass &amp;)\n&quot;</span>;
}
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> Myclass &amp;&amp;)</span>
</span>{
    std::cout&lt;&lt; <span class="hljs-string">&quot;foo(const Myclass &amp;&amp;)\n&quot;</span>;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Myclass m;
    <span class="hljs-type">const</span> Myclass cm;

    <span class="hljs-keyword">auto</span> &amp;&amp;r1 = Myclass{}; 
    <span class="hljs-built_in">foo</span>(std::forward&lt;<span class="hljs-keyword">decltype</span>(r1)&gt;(r1)); <span class="hljs-comment">// foo(Myclass{}) arasnda bir fark yok</span>
    <span class="hljs-keyword">auto</span> &amp;&amp;r2 = m;
    <span class="hljs-built_in">foo</span>(std::forward&lt;<span class="hljs-keyword">decltype</span>(r2)&gt;(r2)); <span class="hljs-comment">// foo(Myclass &amp;)</span>
    <span class="hljs-keyword">auto</span> &amp;&amp;r3 = cm;
    <span class="hljs-built_in">foo</span>(std::forward&lt;<span class="hljs-keyword">decltype</span>(r3)&gt;(r3)); <span class="hljs-comment">// foo(const Myclass &amp;)</span>
    <span class="hljs-keyword">auto</span> &amp;&amp;r4 = std::<span class="hljs-built_in">move</span>(m);
    <span class="hljs-built_in">foo</span>(std::forward&lt;<span class="hljs-keyword">decltype</span>(r4)&gt;(r4)); <span class="hljs-comment">// foo(Myclass &amp;&amp;)</span>
    <span class="hljs-keyword">auto</span> &amp;&amp;r5 = std::<span class="hljs-built_in">move</span>(cm);
    <span class="hljs-built_in">foo</span>(std::forward&lt;<span class="hljs-keyword">decltype</span>(r5)&gt;(r5)); <span class="hljs-comment">// foo(const Myclass &amp;&amp;)    </span>
}
</code></pre>
<p>Dorudan argman olarak gndermek ile argman olarak gndereceiimiz ifadeye universal referans baladk ve bunu fonksiyona argman olarak forward ederek kullandk.</p>
<h4 id="return-value-perfect-passing">Return value perfect passing</h4>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span> {};
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> Myclass &amp;)</span>
</span>{
    std::cout&lt;&lt; <span class="hljs-string">&quot;foo(const Myclass &amp;)\n&quot;</span>;
}
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(Myclass &amp;&amp;)</span>
</span>{
    std::cout&lt;&lt; <span class="hljs-string">&quot;foo(Myclass &amp;&amp;)\n&quot;</span>;
}
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(Myclass &amp;)</span>
</span>{
    std::cout&lt;&lt; <span class="hljs-string">&quot;foo(Myclass &amp;)\n&quot;</span>;
}
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> Myclass &amp;&amp;)</span>
</span>{
    std::cout&lt;&lt; <span class="hljs-string">&quot;foo(const Myclass &amp;&amp;)\n&quot;</span>;
}

<span class="hljs-function"><span class="hljs-type">const</span> Myclass &amp; <span class="hljs-title">func_const_lref</span><span class="hljs-params">(<span class="hljs-type">const</span> Myclass &amp; str)</span></span>{ <span class="hljs-keyword">return</span> str;}
<span class="hljs-function">Myclass &amp; <span class="hljs-title">func_non_const_lref</span><span class="hljs-params">(Myclass &amp; str)</span></span>{ <span class="hljs-keyword">return</span> str;}
<span class="hljs-function">Myclass &amp;&amp; <span class="hljs-title">func_ref</span><span class="hljs-params">(Myclass &amp;&amp; str)</span></span>{ <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(str);}
<span class="hljs-function">Myclass <span class="hljs-title">func_value</span><span class="hljs-params">(Myclass str)</span></span>{ <span class="hljs-keyword">return</span> str;}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Myclass m;
    <span class="hljs-type">const</span> Myclass cm;
    <span class="hljs-built_in">foo</span>(<span class="hljs-built_in">func_rref</span>(Myclass{})); <span class="hljs-comment">// foo(Myclass &amp;&amp;) yukardaki fonksiyonlardan parametresi  Myclass &amp;&amp; olan&#x27;n arlmas lazm.</span>
    <span class="hljs-built_in">foo</span>(<span class="hljs-built_in">func_non_const_lref</span>(m)); <span class="hljs-comment">// foo(const Myclass &amp;)</span>
    <span class="hljs-built_in">foo</span>(<span class="hljs-built_in">func_const_lref</span>(cm)); <span class="hljs-comment">// foo(const Myclass &amp;)</span>
    <span class="hljs-built_in">foo</span>(<span class="hljs-built_in">func_value</span>(m)); <span class="hljs-comment">// foo(Myclass &amp;&amp;)</span>
}
</code></pre>
<p>Func_rref fonksiyonuna geici nesne yolladk ve geilen argman move etti. Geri dn deerini perfect forward aetmek iin zel bir ey yapmamza gerek yok.</p>
<p>Fakat biz bu geri dn deerini bir fonksiyonda tutmak ve daha sonra bu deikeni kullanarak fonksiyon arsn yapmak istiyorsak bu durumda <code>auto &amp;&amp;</code> kullanmak zorudnayz.</p>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T &amp;&amp;t)</span>
</span>{
    <span class="hljs-built_in">foo</span>(<span class="hljs-built_in">bar</span>(std::forward&lt;T&gt;(t)));
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Myclass m;
    <span class="hljs-type">const</span> Myclass cm;
    <span class="hljs-comment">//Type  ret = bar(std::forward&lt;T&gt;(t));</span>
    <span class="hljs-comment">//foo(ret); //buradaki ret&#x27;in tr ne olucak. Bu l&#x27;artk l value oluyor</span>
    <span class="hljs-keyword">auto</span> &amp;&amp; ret = <span class="hljs-built_in">bar</span>(std::forward&lt;T&gt;(t));
    <span class="hljs-built_in">foo</span>(std::forward&lt;<span class="hljs-keyword">decltype</span>(ret)&gt;(ret));
}
</code></pre>
<pre><code class="language-c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ivec</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> val : ivec)
    {
        cout&lt;&lt; val;
    }
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : ivec)
    {
        i = <span class="hljs-number">10</span>;
    }
    cout &lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> val : ivec)
    {
        cout&lt;&lt; val;
    }
}
</code></pre>
<p>Fakat eer vector'n bool specializasyonu varsa bu durumda partial specializasyonu var.</p>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">ivec</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;


    <span class="hljs-keyword">auto</span> x = ivec[<span class="hljs-number">2</span>]; <span class="hljs-comment">//burada proxy object dndryor.</span>
    <span class="hljs-comment">//x bir vector&#x27;un bool almnn referans tr nested type</span>
    <span class="hljs-keyword">auto</span> x = ivec.<span class="hljs-keyword">operator</span>[](<span class="hljs-number">2</span>); 
    ivec[<span class="hljs-number">3</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// yazldnda</span>
    ivec.<span class="hljs-keyword">operator</span>[](<span class="hljs-number">3</span>).<span class="hljs-keyword">operator</span>=(<span class="hljs-literal">true</span>); <span class="hljs-comment">// yazlm oluyor.</span>

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> val : ivec){ cout&lt;&lt; val; }
    <span class="hljs-comment">/*derleyicinin rettii psuedo kod
    auto &amp;&amp;rng = ivec; 
    auto pos = rng.begin();
    auto end = rng.end();
    for(;pos != end; ++pos)
    {
        auto temp = *pos; eer  val referans tr olsayd auto &amp;temp olurdu, sa taraf referans tr olsayd auto &amp;&amp;temp olurdu.
    }
    */</span>

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : ivec){ i = <span class="hljs-literal">true</span>;  }
    cout &lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> val : ivec){ cout&lt;&lt; val; }

    <span class="hljs-keyword">auto</span> iter = ivec.<span class="hljs-built_in">begin</span>();
    iter.<span class="hljs-keyword">operator</span>*(<span class="hljs-number">0</span>) = <span class="hljs-literal">true</span>; <span class="hljs-comment">//bu bize referans ddnremeyeceine gre, proxy nesnesi dnyor</span>
    <span class="hljs-comment">//reference nested type&#x27;ndan nesneye yaplm oluyor.</span>
}
</code></pre>
<blockquote>
<p>Vector'un bool almnn 2 sorunu var 1.container deil, 2.bool tutmuyor. :D</p>
</blockquote>
<pre><code class="language-c++"><span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span>
{
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">reference</span>
    {
        <span class="hljs-keyword">operator</span>=(<span class="hljs-type">bool</span>);
        <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>;
    }
    reference <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> idx);
};
</code></pre>
<p>Eer <code>auto val</code> yerine <code>auto &amp;&amp;val</code> olsayd bu durumun bir etkisi olmayacakt.</p>
<p>Aadaki kodda ama yle bir fill fonksiyonu oluturmakki 1.argmandaki container'a 2.parametredeki val deerini yerletirmek.</p>
<ul>
<li><code>auto &amp;&amp;</code> kullanarak sentaks hatasnn nne geilebiliyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> C, <span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Fill</span><span class="hljs-params">(C &amp; con, <span class="hljs-type">const</span> T&amp; val)</span>
</span>{
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp; elem : con)
    <span class="hljs-comment">//Sentaks hatasn engellemek iin universal refeerans kullanmak gerekiyor. </span>
    {
        elem = val;
    }
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> C, <span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Fill_2</span><span class="hljs-params">(C &amp; con, <span class="hljs-type">const</span> T&amp; val)</span>
</span>{
    <span class="hljs-keyword">auto</span> &amp;&amp;rng = con;
    <span class="hljs-keyword">auto</span> pos = rng.<span class="hljs-built_in">begin</span>();
    <span class="hljs-keyword">auto</span> end = rng.<span class="hljs-built_in">end</span>();
    <span class="hljs-keyword">for</span>(;pos != end; ++pos)
    {
        <span class="hljs-keyword">auto</span> &amp;elem = *pos; <span class="hljs-comment">//pos.operator*() bu fonksiyonun geri dn deeri referans ve r-value expression</span>
        <span class="hljs-comment">//sentaks hatasnn nedeni l-value referansa  r-value expression atanmas</span>
        *pos = val;
    }
}

<span class="hljs-function">inr <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ivec</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> val : ivec)
    {
        cout&lt;&lt; val;
    }
    <span class="hljs-built_in">Fill</span>(ivec, <span class="hljs-number">10</span>);
    cout &lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> val : ivec)
    {
        cout&lt;&lt; val;
    }

    vector&lt;string&gt; svec{<span class="hljs-string">&quot;ali&quot;</span>, <span class="hljs-string">&quot;veli&quot;</span>, <span class="hljs-string">&quot;selami&quot;</span>};
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> val : svec)
    {
        cout&lt;&lt; val;
    }
    <span class="hljs-built_in">Fill</span>(svec, <span class="hljs-string">&quot;necati&quot;</span>);
    cout &lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> val : svec)
    {
        cout&lt;&lt; val;
    }
    vector&lt;<span class="hljs-type">bool</span>&gt; bvec{<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>};
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> val : bvec)
    {
        cout&lt;&lt; val;
    }
    <span class="hljs-comment">//Fill(bvec, true); //SENTAKS HATASI</span>
    cout &lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;
}
</code></pre>
<h4 id="perfect-returning">Perfect Returning</h4>
<p>Amacmz foo'nun geri dndrd gibi olduu gibi func fonksiyonun ayn geri dn deerini dndrmek istiyoruz.</p>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
??? <span class="hljs-built_in">func</span>(T &amp;&amp;t)
{
    <span class="hljs-built_in">foo</span>(std::forward&lt;T&gt;(t));
}
</code></pre>
<p>Geri dn deeri yerine <code>decltype(auto)</code> yazmamz gerekiyor. Peki bu ne demek?</p>
<h5 id="decltypeauto">decltype(auto)</h5>
<p><strong>decltype</strong> iin 2 farkl decltype var.</p>
<ol>
<li>Operand olan ifadenin bir isim formunda olmas, declaration trn elde ediyor</li>
<li>Eer bir expression olursa, bu durumda ifadenin deer kategorisi oluyor:</li>
</ol>
<ul>
<li>PRvalue ==&gt; T</li>
<li>Lvalue ==&gt; T&amp;</li>
<li>Xvalue ==&gt; T&amp;&amp;</li>
</ul>
<p>decltype(auto)' da ise, tpk auto da olduu bir deikene ilk deer verdiimizde, <code>auto</code>nun kurallarna gre deil de <code>decltype</code>a gre belirleniyor.</p>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> &amp; <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-type">int</span> &amp;&amp; <span class="hljs-title">bar</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">f1</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">return</span> expr; <span class="hljs-comment">// int &amp; f1() return type</span>
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">int</span> x = <span class="hljs-number">4</span>;
    <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) y = x; <span class="hljs-comment">// int y = x;</span>
    <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) z = <span class="hljs-number">4</span>; <span class="hljs-comment">// int z = 4;</span>
    <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) t = <span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// int &amp; t = foo();</span>
    <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) u = <span class="hljs-built_in">bar</span>(); <span class="hljs-comment">// int &amp;&amp; u = bar();</span>
    <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) y = (x); <span class="hljs-comment">// x ile yukardaki farkl anlamlara geliyor</span>
    
    <span class="hljs-type">int</span> m{}, * ptr{&amp;m};
    <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) r = m;
    <span class="hljs-comment">//decltpye(auto) ilave bir deklaratr alamyor.</span>
}
</code></pre>
<pre><code class="language-c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Myclass</span>
{

};

<span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">foo</span><span class="hljs-params">(Myclass m)</span>
</span>{
    <span class="hljs-comment">//return m; // Myclass</span>
    <span class="hljs-comment">//return (m); // Myclass &amp; olurdu ve otomatik mrl bir nesneye referans dndrm olur ve hata olurdu.</span>
}
</code></pre>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">fn_A</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>{  <span class="hljs-keyword">return</span> i; }
<span class="hljs-comment">//decltype(auto) fn_B(int i){ return (i); } </span>
<span class="hljs-comment">//Sentaks hatas fonksiyonun geri dn deeri int &amp; otomatik mrl nesneyi dndryor</span>
<span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">fn_C</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>{  <span class="hljs-keyword">return</span> (i+<span class="hljs-number">1</span>); }
<span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">fn_D</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>{  <span class="hljs-keyword">return</span> i++; }
<span class="hljs-comment">// Yok nk son ek ++ operatr oluturduu ifade PR-value expression ve geri dn deeri int</span>
<span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">fn_E</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>{  <span class="hljs-keyword">return</span> ++i;}
<span class="hljs-comment">// n ek ++ operatr oluturduu ifade L-value expression ve geri dn deeri int &amp; otamtik mrl nesneye referans dnyor.</span>
<span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">fn_F</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>{  <span class="hljs-keyword">return</span> (i &gt;= <span class="hljs-number">0</span> ? i : <span class="hljs-number">0</span>); }
<span class="hljs-comment">// Bir problem yok, nk ternary operatornn operandlar PR-value expression ve geri dn deeri int</span>
d<span class="hljs-comment">//ecltype(auto) fn_G(int i, int j) {  return i &gt;= j ? i : j; }</span>
<span class="hljs-comment">// ternary operatr&#x27;n return ifadesinin kategrs gene int &amp; dndryor</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span> {  <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; };
<span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">fn_H</span><span class="hljs-params">()</span></span>{   <span class="hljs-keyword">return</span> (S{});}
<span class="hljs-comment">// fade PR-value expression ve geri dn deeri S</span>
<span class="hljs-comment">//decltype(auto)fn_I(){  return (S{}.i);}</span>
<span class="hljs-comment">// R-value nesnelerin non-static veri elemanlarna eriim ifadesi X-value expression ve dn deeri int &amp;&amp; oluyor ve geici nesneye referans dnyor.</span>
</code></pre>
<p>O zaman bizim bunu perfect return etmemiz iin</p>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;typenamem T&gt;
<span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">foo</span><span class="hljs-params">(T &amp;&amp;val)</span>
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">bar</span>(std::forward&lt;T&gt;(val));
}

<span class="hljs-comment">// lambda fonksiyonlar iin trailing return type kullanmamz gerekiyor.</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">auto</span> fn = [](<span class="hljs-keyword">auto</span> &amp;&amp;r) -&gt; <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">bar</span>(std::forward&lt;<span class="hljs-keyword">decltype</span>(r)&gt;(r));
    }
}
</code></pre>
<ul>
<li>Fonksiyonun geri dn deerini <code>decltype(auto)</code> ile bildirilen bir deikende tuttuk. Bylece geri dn deeri hergangi bir valueType olabilir. Eer burada geri dn deeri:</li>
<li>
<ul>
<li>R-value referans tr ise, <code>if constexpr</code> ile bu saptanyor.</li>
</ul>
</li>
<li>
<ul>
<li>ret value olabilir.</li>
</ul>
</li>
<li>
<ul>
<li>L-value referans olabilir. Bu iki durumda ya value return ya da l-value referans return ediyoruz.</li>
</ul>
</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Func, <span class="hljs-keyword">typename</span>... Args&gt;
<span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">call</span><span class="hljs-params">(Func f, Args&amp;&amp;... args)</span>
</span>{
    <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) ret {<span class="hljs-built_in">f</span>(std::forward&lt;Args&gt;(args)...)};
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::is_rvalue_refeerence_v&lt;<span class="hljs-keyword">decltype</span>(ret)&gt;)</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title">std::move</span><span class="hljs-params">(ret)</span></span>;
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> ret; 
}
</code></pre>
<p>Bunu bir lambda fonksiyonu ile de yapabiliriz.</p>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">auto</span> f = [](<span class="hljs-keyword">auto</span> &amp;&amp;...args) -&gt; <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">func</span>(std::forward&lt;<span class="hljs-keyword">decltype</span>(args)&gt;(args)...);
    };
    <span class="hljs-keyword">auto</span> f1 = [](<span class="hljs-keyword">auto</span> &amp;&amp;...args) -&gt; <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>)
    {
        <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) ret = <span class="hljs-built_in">func</span>(std::forward&lt;<span class="hljs-keyword">decltype</span>(args)&gt;(args)...);
        <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::is_rvalue_reference_v&lt;<span class="hljs-keyword">decltype</span>(ret)&gt;)</span>
            <span class="hljs-keyword">return</span> <span class="hljs-title">std::move</span><span class="hljs-params">(ret)</span></span>;
        <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">return</span> ret;
    }
}
</code></pre>
<ul>
<li>C++23 ncesinde ki sorun, hayat bitmi bir nesneye tekrar kullanmaya alyoruz ve dangling reference oluyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">create_svec</span><span class="hljs-params">()</span></span>;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">for</span>(std::string s : <span class="hljs-built_in">create_svec</span>()){}
    <span class="hljs-comment">// Aadaki 3 dngde tanmsz davran oluturuyor</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c: <span class="hljs-built_in">create_svec</span>().<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>)){} <span class="hljs-comment">// </span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c: <span class="hljs-built_in">create_svec</span>()[<span class="hljs-number">0</span>]){} <span class="hljs-comment">// </span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c: <span class="hljs-built_in">create_svec</span>().<span class="hljs-built_in">front</span>()){} <span class="hljs-comment">//</span>
}
<span class="hljs-comment">//</span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp; r1 = <span class="hljs-built_in">create_svec</span>(); <span class="hljs-comment">//life extension var.</span>
    <span class="hljs-keyword">auto</span> &amp;r = <span class="hljs-built_in">creae_svec</span>(); <span class="hljs-comment">//SENTAKS HATASI sa taraf deeri sol refereansa balanamaz life extension yok </span>
    vector&lt;std::string&gt; &amp;&amp;r2 = <span class="hljs-built_in">create_svec</span>();

     <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp; r3 = <span class="hljs-built_in">create_svec</span>().<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//UNDEFINED BEHAVIOR. Burada life extension yok, </span>
}
</code></pre>
<p>Yukardaki kodlarn sorununu anlamak iin aadkai kodu inceleyelim.</p>
<pre><code class="language-c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span>
{
<span class="hljs-keyword">public</span>:
    ~<span class="hljs-built_in">Myclass</span>(){ std::cout&lt;&lt; <span class="hljs-string">&quot;object Destructed....\n&quot;</span>;}
    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getVec</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>{
        <span class="hljs-keyword">return</span> ivec;
    }
<span class="hljs-keyword">private</span>:
    std::vector&lt;<span class="hljs-type">int</span>&gt; ivec{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>};
};
<span class="hljs-function">Myclass <span class="hljs-title">foo</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">return</span> Myclass{};
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    {
        <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp; r = <span class="hljs-built_in">foo</span>();
        cout&lt;&lt; <span class="hljs-string">&quot;main devam ediyor..1\n&quot;</span>
    }<span class="hljs-comment">//obje burada destruyor olmal</span>
    {
        <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp; r = <span class="hljs-built_in">foo</span>().<span class="hljs-built_in">getVec</span>(); <span class="hljs-comment">//life-extension yok, obje burada destruct ediliyor</span>
        <span class="hljs-comment">//r&#x27;yi kullansaydk tanmsz bir davran oluturmu oluyor.</span>
        cout&lt;&lt; <span class="hljs-string">&quot;main devam ediyor..2\n&quot;</span>
    }
    cout&lt;&lt; <span class="hljs-string">&quot;main devam ediyor..3\n&quot;</span>
}
</code></pre>
<p>C++23 ile bu implementasyon deiti. Umulmadk ve beklenmedik durumlar oluuyor. Bu bizi neden ilgilendiriyor.</p>
<h4 id="reference-qualifier">Reference Qualifier</h4>
<p>Bir ye fonksiyonun hangi deer kategorisindeki nesneler ile alabileceini gsteriyor. rnein l-value referans ile nitelendirilim bir ye fonksiyon.</p>
<p>Aadaki gibi bir fonksiyon yazldna bir kopyalama oluyor. Fakat bunun geri dn deerini <code>const referans</code> yaplarak bir eriim verilebilir.</p>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">myclass</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">std::string <span class="hljs-title">get_str</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>{<span class="hljs-keyword">return</span> m_str;}
<span class="hljs-keyword">private</span>:
    std::string m_str;
};

<span class="hljs-function">Myclass <span class="hljs-title">create_myclass</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">return</span> Myclass{};
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c : <span class="hljs-built_in">create_myclass</span>().<span class="hljs-built_in">get_str</span>()){}
}
</code></pre>
<p>Aadaki kullanmlar legal fakat bunlarn semantik bir anlam yok.</p>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Nec</span>{};
<span class="hljs-function">Nec <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-built_in">foo</span>() = <span class="hljs-built_in">foo</span>()
    Nec{} = <span class="hljs-built_in">Nec</span>();
}
</code></pre>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>&amp;</span>; <span class="hljs-comment">//l-value reference qualifier</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span>&amp;&amp;</span>; <span class="hljs-comment">//l-value reference qualifier</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &amp;</span>; <span class="hljs-comment">//eklinde de olaiblir.</span>
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Myclass m;
    m.<span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// foo(&amp;m)</span>
    Myclass{}.<span class="hljs-built_in">foo</span>(); <span class="hljs-comment">//SENTAKS HATASI</span>
    std::<span class="hljs-built_in">move</span>(m).<span class="hljs-built_in">foo</span>(); <span class="hljs-comment">//SENTAKS HATASI</span>
    m.<span class="hljs-built_in">func</span>(); <span class="hljs-comment">//SENTAKS HATASI</span>
    m.<span class="hljs-built_in">bar</span>(); <span class="hljs-comment">//SENTAKS HATASI</span>

    cm.<span class="hljs-built_in">bar</span>(); <span class="hljs-comment">//</span>
}
</code></pre>
<ul>
<li>Overload da edilebiliyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>&amp;</span>{ std::cout&lt;&lt; <span class="hljs-string">&quot;l-value reference qualifier\n&quot;</span>; } <span class="hljs-comment">//l-value reference qualifier</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>&amp;&amp;</span>{ std::cout&lt;&lt; <span class="hljs-string">&quot;r-value reference qualifier\n&quot;</span>; } <span class="hljs-comment">//l-value reference qualifier</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &amp;</span>{ std::cout&lt;&lt; <span class="hljs-string">&quot;const l-value reference qualifier\n&quot;</span>; } <span class="hljs-comment">//l-value reference qualifier</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &amp;&amp;</span>{ std::cout&lt;&lt; <span class="hljs-string">&quot;const r-value reference qualifier\n&quot;</span>; } <span class="hljs-comment">//l-value reference qualifier</span>
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Myclass m;
    <span class="hljs-type">const</span> Myclass cm;
    m.<span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// foo(&amp;m) </span>
    cm.<span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// foo(&amp;cm)</span>
    Myclass{}.<span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// foo(&amp;&amp;Myclass{})</span>
    <span class="hljs-built_in">move</span>(m).<span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// foo(&amp;&amp;m)</span>
    <span class="hljs-built_in">move</span>(cm).<span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// foo(&amp;&amp;cm)</span>
}
</code></pre>
<ul>
<li>Baz senaryolarda bu ok byk bir hata olabilir. rnein</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">bool</span>)</span></span>{    std::cout&lt;&lt; <span class="hljs-string">&quot;foo(bool)\n&quot;</span>;}
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(std::string)</span>  </span>{    std::cout&lt;&lt; <span class="hljs-string">&quot;foo(std::string)\n&quot;</span>;}
<span class="hljs-function">std::string <span class="hljs-title">getStr</span><span class="hljs-params">()</span></span>{ <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;necati&quot;</span>;}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-comment">//if(getstr() = &quot;necati&quot;)  //SENTAKS HATASI nk boola dntrlemez.</span>
    <span class="hljs-built_in">foo</span>(<span class="hljs-built_in">getstr</span>() == <span class="hljs-string">&quot;necati&quot;</span>);
    <span class="hljs-built_in">foo</span>(<span class="hljs-built_in">getstr</span>() = <span class="hljs-string">&quot;necati&quot;</span>); <span class="hljs-comment">// Sentaks hatas yok ve parametresi string olan fonksiyon arlyor.</span>
    <span class="hljs-comment">// ilk olarak atama operatr arlyor ve bu atama operatr fonksiyonu reference qualifier deil ve teknik bir engel yok.</span>
    <span class="hljs-comment">// bu kod foo(getstr().operator=(&quot;necati&quot;)) eklinde alyor. Operator atama fonksiyonun geri dn deeri *this. ve string overload&#x27;da alr.</span>
}
</code></pre>
<p>Move semantii ile kullanmna bir rnek</p>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> std::string &amp;name) : m_name{name}{}
    <span class="hljs-function">std::string &amp; <span class="hljs-title">get_name</span><span class="hljs-params">()</span> &amp;&amp;</span>{  std::cout&lt;&lt; <span class="hljs-string">&quot;r-value reference qualifier\n&quot;</span>; <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(m_name); }
    <span class="hljs-function">std::string &amp; <span class="hljs-title">get_name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &amp;</span>{  std::cout&lt;&lt; <span class="hljs-string">&quot;l-value reference qualifier\n&quot;</span>; <span class="hljs-keyword">return</span> m_name; }
    <span class="hljs-function">std::string &amp; <span class="hljs-title">get_name</span><span class="hljs-params">()</span> &amp; </span>{  std::cout&lt;&lt; <span class="hljs-string">&quot;const l-value reference qualifier\n&quot;</span>; <span class="hljs-keyword">return</span> m_name; }
<span class="hljs-keyword">private</span>:
    std::string m_name;
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T &amp;&amp;x)</span>
</span>{
    <span class="hljs-keyword">auto</span> name = std::forward&lt;T&gt;(x).<span class="hljs-built_in">get_name</span>();
    std::cout&lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Person p{<span class="hljs-string">&quot;necati&quot;</span>};
    <span class="hljs-type">const</span> Person cp{<span class="hljs-string">&quot;necati&quot;</span>};
    <span class="hljs-built_in">foo</span>(p); <span class="hljs-comment">// l-value reference qualifier</span>
    <span class="hljs-built_in">foo</span>(cp); <span class="hljs-comment">// l-value reference qualifier</span>
    <span class="hljs-built_in">foo</span>(Person{<span class="hljs-string">&quot;necati&quot;</span>}); <span class="hljs-comment">// r-value reference qualifier</span>
    <span class="hljs-built_in">foo</span>(std::<span class="hljs-built_in">move</span>(p)); <span class="hljs-comment">// r-value reference qualifier</span>
    <span class="hljs-built_in">foo</span>(std::<span class="hljs-built_in">move</span>(cp)); <span class="hljs-comment">// l-value reference qualifier</span>
}
</code></pre>
<h3 id="universal-referans-olmayan-fakat-yle-gzken-senaryolar">Universal Referans Olmayan Fakat yle Gzken Senaryolar</h3>
<p>rnein aadaki kod universal referans deil, const sa taraf referans.</p>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp;&amp;)</span></span>{}
</code></pre>
<p>Nested type'lar, burada x'in tr sa taraf referans.</p>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(Con &amp; x, <span class="hljs-keyword">typename</span> Con::value_type &amp;&amp;)</span></span>{}
</code></pre>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(std::vector&lt;T&gt; &amp;&amp;)</span></span>{}
</code></pre>
<p>generic bir snfta kullandmz zaman universal referans <strong>olmayan</strong> bir fonksiyon yazm oluyoruz.</p>
<pre><code class="language-c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;&amp;)</span>
    </span>{
        std::cout&lt;&lt; <span class="hljs-string">&quot;push(const T &amp;&amp;)\n&quot;</span>;
        m_con.<span class="hljs-built_in">push_back</span>(val);
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T &amp;&amp;)</span>
    </span>{
        std::cout&lt;&lt; <span class="hljs-string">&quot;push(T &amp;&amp;)\n&quot;</span>;
        m_con.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(val));
    }

<span class="hljs-keyword">private</span>:
    std::vector&lt;T&gt; m_con;
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Stack&lt;std::string&gt; istack;
    std::string str{<span class="hljs-string">&quot;lvalue&quot;</span>};
    istack.<span class="hljs-built_in">push</span>(str);
    istack.<span class="hljs-built_in">push</span>(std::<span class="hljs-built_in">move</span>(str));
}
</code></pre>
<p>Fonksiyonun parametresi ne olmal?</p>
<ul>
<li>Elimizde bir snf trnden parametre alan ve salt okuma yapan bir fonksiyon olsun:</li>
<li>
<ul>
<li>Eer bu string'in tersten okunmas gerekiyorsa</li>
</ul>
</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp; str)</span>
</span>{
    <span class="hljs-keyword">auto</span> stem = str;
    <span class="hljs-built_in">reverse</span>(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">end</span>());
}
</code></pre>
<blockquote>
<p>ADL: Argument Dependent Lookup: Eer fonksiyonua gnderilen agmanlardan biri bir namespace ierisinde tanmlanm tre ilikin ise, o zaman fonksiyon ismi o namespace ierisinde de aranr.</p>
</blockquote>
<h2 id="move-only-types">Move Only Types</h2>
<p>Snflar problem domainindeki varlklar temsil etme amac olarak kullanlyor ve bu varlklardan bazlar kopyalamaya uygun ya da birden fazla probleme yol alyor. Snflar bunu engellemek iin kopyalamaya kar kapatlyor. Fakat bu varlk eer bir kayna tutuyorsa o kayna tekrar kullanmak iin move edilebiliyor.</p>
<p>Bu snf:</p>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MoveOnly</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">MoveOnly</span>() = <span class="hljs-keyword">default</span>;
    <span class="hljs-built_in">MoveOnly</span>(<span class="hljs-type">const</span> MoveOnly&amp;) = <span class="hljs-keyword">delete</span>;
    MoveOnly&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MoveOnly&amp;) = <span class="hljs-keyword">delete</span>;
    <span class="hljs-built_in">MoveOnly</span>(MoveOnly&amp;&amp;) = <span class="hljs-keyword">default</span>;
    MoveOnly&amp; <span class="hljs-keyword">operator</span>=(MoveOnly&amp;&amp;) = <span class="hljs-keyword">default</span>;
};
</code></pre>
<p>Tanmlayabiliyoruz. Move memberlar iin 2 seeneimiz var, bu memberlar biz yazabiliriz ya da compiler bunu bizim iin yazabilir.</p>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MoveOnly</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">MoveOnly</span>() = <span class="hljs-keyword">default</span>;
    <span class="hljs-built_in">MoveOnly</span>(<span class="hljs-type">const</span> MoveOnly&amp;) = <span class="hljs-keyword">delete</span>;
    MoveOnly&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MoveOnly&amp;) = <span class="hljs-keyword">delete</span>;
    <span class="hljs-built_in">MoveOnly</span>(MoveOnly&amp;&amp;){ std::cout&lt;&lt; <span class="hljs-string">&quot;MoveOnly(MoveOnly&amp;&amp;)\n&quot;</span>; }
    MoveOnly&amp; <span class="hljs-keyword">operator</span>=(MoveOnly&amp;&amp;){ std::cout&lt;&lt; <span class="hljs-string">&quot;MoveOnly&amp; operator=(MoveOnly&amp;&amp;)\n&quot;</span>; }
};

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(MoveOnly m)</span>
</span>{
    std::cout&lt;&lt; <span class="hljs-string">&quot;func(MoveOnly m)\n&quot;</span>;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    MoveOnly m;
    <span class="hljs-built_in">func</span>(m); <span class="hljs-comment">// SENTAKS HATASI</span>
    <span class="hljs-built_in">func</span>(std::<span class="hljs-built_in">move</span>(m)); <span class="hljs-comment">// MoveOnly(MoveOnly&amp;&amp;)</span>
}
</code></pre>
<hr>
<p><strong>Inittializer List Hatrlatma</strong>:</p>
<ul>
<li>Container'lar sz konusu olduunda <strong>initializer listleri</strong> var:</li>
<li>
<ul>
<li>Derleyici burada arka planda bir array oluturuluyor ve bu arrayin elerini initializer listteki elerle hayata balyor ve burada bir <strong>kopyalama</strong> oluyor.</li>
</ul>
</li>
<li>
<ul>
<li>Yani bunlar move only type'lar ile kullanamyoruz. Initializer listessi arka planda 2 tane pointer tutuyor (Biri balangcn br de bittii yerini tutuyor).</li>
</ul>
</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(std::initializer_list&lt;MoveOnly&gt; ilist)</span>
</span>{
    cout &lt;&lt; <span class="hljs-string">&quot;&amp;ilist &quot;</span>&lt;&lt; &amp;ilist&lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    cout &lt;&lt; <span class="hljs-string">&quot;dizi adresi &quot;</span>&lt;&lt; ilist.<span class="hljs-built_in">begin</span>()&lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    std::initializer_list&lt;<span class="hljs-type">int</span>&gt; mylist{<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>};
    cout &lt;&lt; <span class="hljs-string">&quot;&amp;ilist &quot;</span>&lt;&lt; &amp;mylist&lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    cout &lt;&lt; <span class="hljs-string">&quot;dizi adresi &quot;</span>&lt;&lt; mylist.<span class="hljs-built_in">begin</span>()&lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-built_in">func</span>(mylist);
}
</code></pre>
<ul>
<li>Size veya distance fonksiyonu arlarak boyutu elde edilebilir. For-based range loop ile de kullanlabilir.</li>
<li>Constructor'larda kullanlyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span>
</span>{
    std::vector&lt;<span class="hljs-type">int</span>&gt; ivec{a,b,c};
    ivec = {a,b,c};
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    vector&lt;<span class="hljs-type">int</span>&gt; ivec{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>};
}
</code></pre>
<ul>
<li>Initializer list parametreli bir constructor'n ncelii daha yksek.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Myclass</span>(<span class="hljs-type">int</span>){ std::cout&lt;&lt; <span class="hljs-string">&quot;Myclass(int)\n&quot;</span>; }
    <span class="hljs-built_in">Myclass</span>(std::initializer_list&lt;<span class="hljs-type">int</span>&gt;){ std::cout&lt;&lt; <span class="hljs-string">&quot;Myclass(std::initializer_list&lt;int&gt;)\n&quot;</span>; }
};
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Myclass myNec{<span class="hljs-number">10</span>};
    <span class="hljs-function">Myclass <span class="hljs-title">myNec1</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;
}
</code></pre>
<p>Burada gennnellikle string snf iin soruluyor.</p>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    cout &lt;&lt; <span class="hljs-built_in">string</span>(<span class="hljs-number">66</span>,<span class="hljs-string">&quot;X&quot;</span>)&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;
    cout &lt;&lt; string{<span class="hljs-number">66</span>,<span class="hljs-string">&quot;X&quot;</span>}&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;
    cout &lt;&lt; <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">19</span>,<span class="hljs-number">10</span>).<span class="hljs-built_in">size</span>()&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;
    cout &lt;&lt; vector&lt;<span class="hljs-type">int</span>&gt;{<span class="hljs-number">19</span>,<span class="hljs-number">10</span>}.<span class="hljs-built_in">size</span>()&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;
}
</code></pre>
<blockquote>
<p>STL'de genellikle insert ilemlerinde ayr ayr armak yerine tek bir fonksiyon ars ile yapabiliyorsak o ar ile yapabiliriz.</p>
</blockquote>
<hr>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MoveOnly</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">MoveOnly</span>() = <span class="hljs-keyword">default</span>;
    <span class="hljs-built_in">MoveOnly</span>(<span class="hljs-type">const</span> MoveOnly&amp;) = <span class="hljs-keyword">delete</span>;
    MoveOnly&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MoveOnly&amp;) = <span class="hljs-keyword">delete</span>;
    <span class="hljs-built_in">MoveOnly</span>(MoveOnly&amp;&amp;){ std::cout&lt;&lt; <span class="hljs-string">&quot;MoveOnly(MoveOnly&amp;&amp;)\n&quot;</span>; }
    MoveOnly&amp; <span class="hljs-keyword">operator</span>=(MoveOnly&amp;&amp;){ std::cout&lt;&lt; <span class="hljs-string">&quot;MoveOnly&amp; operator=(MoveOnly&amp;&amp;)\n&quot;</span>; }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    <span class="hljs-comment">//vecotr&lt;MoveOnly&gt; ivec{MoveOnly{}, MoveOnly{}, MoveOnly{}}; // SENTAKS HATASI nk burada kopyalama semantii iliyor.</span>
    <span class="hljs-function">vector&lt;MoveOnly&gt; <span class="hljs-title">myvec</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;
    <span class="hljs-comment">//for(auto x : myvec){} //SENTAKS HATASI nk burada gene kopyalama yaplyor.</span>
}
</code></pre>
<p><code>print_tr()</code> fonksiyonu ile amacmz snfn hangi zelliklere sahip olduunu grmek.</p>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MoveOnly</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">MoveOnly</span>() = <span class="hljs-keyword">default</span>;
    <span class="hljs-built_in">MoveOnly</span>(<span class="hljs-type">const</span> MoveOnly&amp;) = <span class="hljs-keyword">delete</span>;
    MoveOnly&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MoveOnly&amp;) = <span class="hljs-keyword">delete</span>;
    <span class="hljs-built_in">MoveOnly</span>(MoveOnly&amp;&amp;){ std::cout&lt;&lt; <span class="hljs-string">&quot;MoveOnly(MoveOnly&amp;&amp;)\n&quot;</span>; }
    MoveOnly&amp; <span class="hljs-keyword">operator</span>=(MoveOnly&amp;&amp;){ std::cout&lt;&lt; <span class="hljs-string">&quot;MoveOnly&amp; operator=(MoveOnly&amp;&amp;)\n&quot;</span>; }
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_tr</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::is_default_constructible_v&lt;T&gt;)</span>
    </span>{
        std::cout&lt;&lt; <span class="hljs-string">&quot;default constructible\n&quot;</span>;
    }
    <span class="hljs-keyword">else</span>
    {
        std::cout&lt;&lt; <span class="hljs-string">&quot;not default constructible\n&quot;</span>;
    }
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::is_destructible_v&lt;T&gt;)</span>
    </span>{
        std::cout&lt;&lt; <span class="hljs-string">&quot;destructible\n&quot;</span>;
    }
    <span class="hljs-keyword">else</span>
    {
        std::cout&lt;&lt; <span class="hljs-string">&quot;not destructible\n&quot;</span>;
    }
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::is_copy_constructible_v&lt;T&gt;)</span>
    </span>{
        std::cout&lt;&lt; <span class="hljs-string">&quot;copy constructible\n&quot;</span>;
    }
    <span class="hljs-keyword">else</span>
    {
        std::cout&lt;&lt; <span class="hljs-string">&quot;not copy constructible\n&quot;</span>;
    }
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::is_copy_assignable_v&lt;T&gt;)</span>
    </span>{
        std::cout&lt;&lt; <span class="hljs-string">&quot;copy assignable\n&quot;</span>;
    }
    <span class="hljs-keyword">else</span>
    {
        std::cout&lt;&lt; <span class="hljs-string">&quot;not copy assignable\n&quot;</span>;
    }
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::is_move_constructible_v&lt;T&gt;)</span>
    </span>{
        std::cout&lt;&lt; <span class="hljs-string">&quot;move constructible\n&quot;</span>;
    }
    <span class="hljs-keyword">else</span>
    {
        std::cout&lt;&lt; <span class="hljs-string">&quot;not move constructible\n&quot;</span>;
    }
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::is_move_assignable_v&lt;T&gt;)</span>
    </span>{
        std::cout&lt;&lt; <span class="hljs-string">&quot;move assignable\n&quot;</span>;
    }
    <span class="hljs-keyword">else</span>
    {
        std::cout&lt;&lt; <span class="hljs-string">&quot;not move assignable\n&quot;</span>;
    }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span>{}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">print_tr</span>&lt;Myclass&gt;();
    <span class="hljs-built_in">print_tr</span>&lt;MoveOnly&gt;();
}
</code></pre>
<h2 id="stlde-move-semantics-ve-perfect-forwarding">STL'de Move Semantics ve Perfect Forwarding</h2>
<ul>
<li>
<p>iostream snf</p>
</li>
<li>
<p>ofs move-only bir snf olmasna ramen nesneyi dndrd.</p>
</li>
</ul>
<pre><code class="language-c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;initializer_list&gt;</span></span>

<span class="hljs-function">std::ofstream <span class="hljs-title">create_file</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;name)</span>
</span>{
    std::ofstream ofs{name};
    <span class="hljs-keyword">if</span>(!ofs)
    {
        <span class="hljs-keyword">throw</span> std::runtime_error{ name + <span class="hljs-string">&quot;File cannot be opened&quot;</span>};
    }
    <span class="hljs-keyword">return</span> ofs;
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(std::ofstream ofs)</span></span>{}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(std::ofstream &amp; ofs)</span></span>;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">auto</span> ofs = <span class="hljs-built_in">create_file</span>(<span class="hljs-string">&quot;test.txt&quot;</span>);
    <span class="hljs-comment">//write(ofs); SENTAKS HATASI nk kopyalamaya kar kapal.</span>
    <span class="hljs-comment">//write(std::move(ofs)); </span>
    <span class="hljs-built_in">func</span>(ofs); <span class="hljs-comment">// bu aktarmda dikkatli olmak gerekiyor</span>
    <span class="hljs-comment">//Burada dosyann durumunu bilmemiz iin func fonksiyonunun ne yaptn bilemiyoruz.</span>
}
</code></pre>
<ul>
<li>string snf</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    string str{<span class="hljs-string">&quot;dogruyum\ncaliskanim\nbuyuklerimi saymak\nkucuklerimi sevmek\n&quot;</span>};
    istringstream iss{str};
    string name; 
    iss &gt;&gt; name;<span class="hljs-comment">//geline(iss,name) de yapabilirdik.</span>
    cout &lt;&lt;<span class="hljs-string">&quot;|&quot;</span> &lt;&lt; name &lt;&lt;<span class="hljs-string">&quot;|\n&quot;</span>
}
</code></pre>
<p>Modern cpp ile bu inserter ve extractor'un sa taraf referansll overloadlar da ekledi</p>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    string str{<span class="hljs-string">&quot;dogruyum\ncaliskanim\nbuyuklerimi saymak\nkucuklerimi sevmek\n&quot;</span>};
    <span class="hljs-type">int</span> x = <span class="hljs-number">345</span>;
    string name {<span class="hljs-string">&quot;cansin&quot;</span>};
    <span class="hljs-type">double</span> dval = <span class="hljs-number">4.2</span>;
    <span class="hljs-keyword">auto</span> s = (ostringstream <span class="hljs-built_in">oss</span>()&lt;&lt; x &lt;&lt; name &lt;&lt; dval).<span class="hljs-built_in">str</span>();
    cout &lt;&lt; s &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;

    ofstream ofs{<span class="hljs-string">&quot;test.txt&quot;</span>};

}
</code></pre>
<ul>
<li>Bir vector tand zaman, moved-from state'deki vector'n size' 0 oluyor. Bu standartlarda garantili bir durum.</li>
</ul>
<h3 id="algoritmalar">Algoritmalar</h3>
<h3 id="remove--remove_if--unique">remove &amp; remove_if &amp; unique</h3>
<ul>
<li>Stl'deki baz silme algoritmalar biz farknda olmasakta tanmaya neden olabilir. Algoritmalarn ounun parametreleri iterator olduu iin silme ilemleri yapamyor ve bu algoritmalar o range'teki eeleri arrange ediyorlar.</li>
<li>elerin says deimiyor fakat baz eler moved-from state'de olabilir.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ForIt, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
<span class="hljs-function">ForIt <span class="hljs-title">Remove</span><span class="hljs-params">(ForIt first, ForIt last, <span class="hljs-type">const</span> T &amp;val)</span>
</span>{
    first = std::<span class="hljs-built_in">find</span>(first, last, val);
    <span class="hljs-keyword">if</span>(first != last)
         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i = first; ++i != last;)
             <span class="hljs-keyword">if</span>(!(*i == val))
                *first++ = std::<span class="hljs-built_in">move</span>(*i); <span class="hljs-comment">//Burada neseneler moved-from state kalyor olabilir.</span>
     <span class="hljs-keyword">return</span> first;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ForIt, <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnaryPred</span>&gt;
<span class="hljs-function">ForIt <span class="hljs-title">remove_if</span><span class="hljs-params">(ForIt first, ForIt last, UnaryPred f)</span>
</span>{
    first = std::<span class="hljs-built_in">find_if</span>(first, last, f);
    <span class="hljs-keyword">if</span>(first != last)
         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i = first; ++i != last;)
             <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">f</span>(*i))
 
                *first++ = std::<span class="hljs-built_in">move</span>(*i);
     <span class="hljs-keyword">return</span> first;
}
</code></pre>
<blockquote>
<p>Remove bir range'teki eleri logic silme ilemine tabi tutuyor. Remove_if bir unaryPredicat'in true deer verdii durumlarda logic silme yapyor.
Unique ise ayn deere sahip yelerin saysn 1'e indiriyor.</p>
</blockquote>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    vector&lt;string&gt; svec{<span class="hljs-string">&quot;ali&quot;</span>, <span class="hljs-string">&quot;veli&quot;</span>, <span class="hljs-string">&quot;selami&quot;</span>, <span class="hljs-string">&quot;necati&quot;</span>, <span class="hljs-string">&quot;ali&quot;</span>, <span class="hljs-string">&quot;veli&quot;</span>, <span class="hljs-string">&quot;selami&quot;</span>, <span class="hljs-string">&quot;necati&quot;</span>};
    <span class="hljs-keyword">auto</span> iter = <span class="hljs-built_in">remove_if</span>(svec.<span class="hljs-built_in">begin</span>(),svec.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> string &amp;s){ <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;i&#x27;</span>) != std::string::npos;});
    <span class="hljs-type">int</span> cnt{};
    <span class="hljs-keyword">while</span>(iter != svec.<span class="hljs-built_in">end</span>())
    {
        cout&lt;&lt; ++cnt; &lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;*iter++ &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
        
    }
}
</code></pre>
<p>Snfn veri elemanlarn initalize etmek iin birden fazla yntem kullanyor olabiliriz. Josutis 3 tane ayr snf oluturuyor.</p>
<pre><code class="language-c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonClassic</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">PersonClassic</span>(<span class="hljs-type">const</span> std::string &amp;name, <span class="hljs-type">const</span> std::string &amp;surname) : m_name{name}, m_surname{surname}{}
<span class="hljs-keyword">private</span>:
std::string m_name;
std::string m_surname;
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonInitMove</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">PersonInitMove</span>(std::string name, std::string surname) : m_name{std::<span class="hljs-built_in">move</span>(name)}, m_surname{std::<span class="hljs-built_in">move</span>(surname)}{}
<span class="hljs-keyword">private</span>:
    std::string m_name;
    std::string m_surname;
};
<span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonInitOverload</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">PersonInitOverload</span>(std::string name, std::string surname) : m_name{std::<span class="hljs-built_in">move</span>(name)}, m_surname{std::<span class="hljs-built_in">move</span>(surname)}{}
    <span class="hljs-built_in">PersonInitOverload</span>(<span class="hljs-type">const</span> std::string &amp;name, <span class="hljs-type">const</span> std::string &amp;surname) : m_name{name}, m_surname{surname}{}
    <span class="hljs-built_in">PersonInitOverload</span>(std::string&amp;&amp; name, <span class="hljs-type">const</span> std::string &amp;surname) : m_name{std::<span class="hljs-built_in">move</span>(name)}, m_surname{surname}{}
    <span class="hljs-built_in">PersonInitOverload</span>(<span class="hljs-type">const</span> std::string &amp;name, std::string&amp;&amp; surname) : m_name{name}, m_surname{std::<span class="hljs-built_in">move</span>(surname)}{}
    <span class="hljs-built_in">PersonInitOverload</span>(std::string&amp;&amp; name, std::string&amp;&amp; surname) : m_name{std::<span class="hljs-built_in">move</span>(name)}, m_surname{std::<span class="hljs-built_in">move</span>(surname)}{}
    <span class="hljs-built_in">PersonInitOverload</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *surname) : m_name{name}, m_surname{surname}{}
    <span class="hljs-built_in">PersonInitOverload</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">const</span> std::string &amp;surname) : m_name{name}, m_surname{surname}{}
    <span class="hljs-built_in">PersonInitOverload</span>(<span class="hljs-type">const</span> std::string &amp;name, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *surname) : m_name{name}, m_surname{surname}{}
    <span class="hljs-built_in">PersonInitOverload</span>(std::string&amp;&amp; name, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *surname) : m_name{std::<span class="hljs-built_in">move</span>(name)}, m_surname{surname}{}
    <span class="hljs-built_in">PersonInitOverload</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, std::string&amp;&amp; surname) : m_name{name}, m_surname{std::<span class="hljs-built_in">move</span>(surname)}{}  
<span class="hljs-keyword">private</span>:
    std::string m_name;
    std::string m_surname;
};

<span class="hljs-type">const</span> <span class="hljs-type">char</span>* pname = <span class="hljs-string">&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;</span>;
<span class="hljs-type">const</span> <span class="hljs-type">char</span>* psurname = <span class="hljs-string">&quot;yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy&quot;</span>;

<span class="hljs-keyword">using</span> Person = PersonClassic;
<span class="hljs-comment">//using Person = PersonInitOverload;</span>
<span class="hljs-comment">//using Person = PersonInitMove;</span>
 
std::<span class="hljs-function">chrono::nanoseconds <span class="hljs-title">measure</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>
</span>{
    std::chrono::nanoseconds total_duration{};
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;num ; ++i)
    {
        <span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">(<span class="hljs-number">100</span>,<span class="hljs-string">&#x27;N&#x27;</span>)</span></span>;
        <span class="hljs-function">std::string <span class="hljs-title">surname</span><span class="hljs-params">(<span class="hljs-number">100</span>,<span class="hljs-string">&#x27;S&#x27;</span>)</span></span>;
        <span class="hljs-keyword">auto</span> start = std::chrono::steady_clock::<span class="hljs-built_in">now</span>();
        Person px{pname, psurname};
        Person p1{name, surname};
        Person p3{std::<span class="hljs-built_in">move</span>(name), std::<span class="hljs-built_in">move</span>(surname)};
        <span class="hljs-keyword">auto</span> end = std::chrono::steady_clock::<span class="hljs-built_in">now</span>();
        total_duration += end - start;
    }
    <span class="hljs-keyword">return</span> total_duration;
}

<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> n = <span class="hljs-number">100&#x27;000</span>;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">measue</span>(<span class="hljs-number">20</span>);
    std::chrono::nanoseconds nanosecond_duration{<span class="hljs-built_in">measure</span>(n)};
    std::chrono::duration&lt;<span class="hljs-type">double</span>, std::milli&gt;millisecond_duration{nanosecond_duration};
    std::cout&lt;&lt; <span class="hljs-string">&quot;test resuls for &quot;</span>&lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; runs\n&quot;</span> &lt;&lt; millisecond_duration.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot;ms\n&quot;</span>;
    std::cout&lt;&lt; <span class="hljs-string">&quot;test resuls for &quot;</span>&lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; runs\n&quot;</span> &lt;&lt; nanosecond_duration.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot;ns\n&quot;</span>;
}
</code></pre>
<p><a href="https://www.onlinegdb.com/online_c++_compiler">onlinegdb</a></p>
<p>En yava alan parametresi const referans olan. En hzl alan ise move olan.</p>
<h3 id="emplace">Emplace</h3>
<ul>
<li>Push back eklenecek nesnenin nerede construct edildiini biliyor. Sol referans olan overload'n da copy-constructor aryor, sa taraf referansta olan ise move constructor' aryor.</li>
<li>Emplace back C++17 ile artk geri dn deeri var ve <code>constexpr T&amp;</code> dnyor.</li>
<li>
<ul>
<li>emplace yapldnda ne copy ne de move constructor arlyor. Burada container'n allocator'nn edindii alanda nesneyi oluturuyor. Move-only bir snf ierisinde bu arlabilir.</li>
</ul>
</li>
<li>
<ul>
<li>emplace back arldnda argmanlarn gnderildii constructor'da dier snf nesneleri iin move-constructor' arabiliyor.</li>
</ul>
</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Allocator = std::allocator&lt;T&gt;&gt;
<span class="hljs-keyword">class</span> Vector
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-type">void</span> <span class="hljs-built_in">push_back</span>(<span class="hljs-type">const</span> T &amp;val)
    {
        <span class="hljs-comment">//new(place)T(t);</span>
        <span class="hljs-keyword">if</span>(m_size == m_capacity)
            <span class="hljs-built_in">reserve</span>(m_capacity * <span class="hljs-number">2</span>);
        m_allocator.<span class="hljs-built_in">construct</span>(m_elem + m_size, val);
        ++m_size;
    }

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(T &amp;&amp;val)</span>
    </span>{
        <span class="hljs-comment">//new(place)T(std::move(t));</span>
        <span class="hljs-keyword">if</span>(m_size == m_capacity)
            <span class="hljs-built_in">reserve</span>(m_capacity * <span class="hljs-number">2</span>);
        m_allocator.<span class="hljs-built_in">construct</span>(m_elem + m_size, std::<span class="hljs-built_in">move</span>(val));
        ++m_size;
    }
    
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Args&gt;
    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> T&amp; <span class="hljs-title">emplace_back</span><span class="hljs-params">(Args&amp;&amp;... args)</span>
    </span>{
        <span class="hljs-comment">//new(place)T(std::forward&lt;Args&gt;(args)...</span>

        <span class="hljs-keyword">if</span>(m_size == m_capacity)
            <span class="hljs-built_in">reserve</span>(m_capacity * <span class="hljs-number">2</span>);
        m_allocator.<span class="hljs-built_in">construct</span>(m_elem + m_size, std::forward&lt;Args&gt;(args)...);
        ++m_size;
        <span class="hljs-keyword">return</span> m_elem[m_size - <span class="hljs-number">1</span>];
    }
<span class="hljs-keyword">private</span>:
 
};

<span class="hljs-comment">//Emplace_back 2. faydas, birden fazla parametreli olan olabilir.</span>

vector&lt;Fighter&gt; fvec;
fvec.<span class="hljs-built_in">emplace_back</span>(exp1, exp2, exp3); <span class="hljs-comment">//bu argmanlarda snfn constructor&#x27;na geiriliyor </span>
<span class="hljs-comment">// ve  bunlar R-value expresionsa bunlar iin de move constructor arlyor.</span>
</code></pre>
<h3 id="copy_backward-algoritmas">Copy_backward algoritmas</h3>
<p>Elimizde bir vektr var ve</p>
<pre><code class="language-c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;nutility.h&quot;</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ivec</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;
    <span class="hljs-built_in">iota</span>(ivec.<span class="hljs-built_in">begin</span>(),ivec.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);
    <span class="hljs-built_in">print</span>(ivec);
    <span class="hljs-comment">//ilk 1.eyi 3.eye gelecek ekilde kopyalamak istiyorsak.</span>
    <span class="hljs-built_in">copy_backward</span>(ivec.<span class="hljs-built_in">begin</span>(), ivec.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">5</span>, ivec.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">7</span>); <span class="hljs-comment">//yazma range&#x27;nin end iterator&#x27;</span>
    <span class="hljs-built_in">print</span>(ivec);
}
</code></pre>
<blockquote>
<p><code>std::iota(ivec.begin(),ivec.end(),0)</code> ile 0'dan balayarak 10'a kadar olan saylar ivec'e atyoruz.
copy_backward ile reverse copy arasnda fark var.</p>
</blockquote>
<p>Copy_backward:</p>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> InIter, <span class="hljs-keyword">typename</span> OutIter&gt;
OutIter <span class="hljs-title">Copy</span><span class="hljs-params">(InIter first, InIter last, OutIter dest_first)</span>
</span>{
    <span class="hljs-keyword">while</span> (first != last)
    {
        *dest_first++ = *first++;
    }
    <span class="hljs-keyword">return</span> dest_first;
}

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> BidIt1, <span class="hljs-keyword">typename</span>  BidIt2&gt;
BidIt2 <span class="hljs-title">CopyBackward</span><span class="hljs-params">(BidIt1 first, BidIt1 last, BidIt2 dest_last)</span>
</span>{
    <span class="hljs-keyword">while</span>(last != first)
        *--dest_last = *--last;
    <span class="hljs-keyword">return</span> dest_last;
}
</code></pre>
<h3 id="move_backward-algoritmas">Move_backward algoritmas</h3>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> InIter, <span class="hljs-keyword">typename</span> OutIter&gt;
OutIter <span class="hljs-title">Move</span><span class="hljs-params">(InIter first, InIter last, OutIter dest_first)</span>
</span>{
    <span class="hljs-keyword">while</span> (first != last)
    {
        *dest_first++ = std::<span class="hljs-built_in">move</span>(*first++);
    }
    <span class="hljs-keyword">return</span> dest_first;
}

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> BidIt1, <span class="hljs-keyword">typename</span>  BidIt2&gt;
BidIt2 <span class="hljs-title">MoveBackward</span><span class="hljs-params">(BidIt1 first, BidIt1 last, BidIt2 dest_last)</span>
</span>{
    <span class="hljs-keyword">while</span>(last != first)
        *--dest_last = std::<span class="hljs-built_in">move</span>(*--last);
    <span class="hljs-keyword">return</span> dest_last;
}
</code></pre>
<p>rnein:</p>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    vector&lt;string&gt; sv{<span class="hljs-string">&quot;ali&quot;</span>, <span class="hljs-string">&quot;veli&quot;</span>, <span class="hljs-string">&quot;selami&quot;</span>, <span class="hljs-string">&quot;necati&quot;</span>, <span class="hljs-string">&quot;ali&quot;</span>, <span class="hljs-string">&quot;veli&quot;</span>, <span class="hljs-string">&quot;selami&quot;</span>, <span class="hljs-string">&quot;necati&quot;</span>};
    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">destvec</span><span class="hljs-params">(svec.size())</span></span>;
    <span class="hljs-built_in">copy</span>(svec.<span class="hljs-built_in">begin</span>(), svec.<span class="hljs-built_in">end</span>(), destvec.<span class="hljs-built_in">begin</span>());
    <span class="hljs-built_in">print</span>(destvec);
    <span class="hljs-type">int</span> count{};
    <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;name:svec)
    {
        cout&lt;&lt; ++count &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt;name &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;
    }        
    cout&lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-built_in">move</span>(svec.<span class="hljs-built_in">begin</span>(), svec.<span class="hljs-built_in">end</span>(), destvec.<span class="hljs-built_in">begin</span>());
    count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;name:svec)
    {
        cout&lt;&lt; ++count &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt;name &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;
    }   
}
</code></pre>
<h3 id="move-iteratr-adaptr">Move Iteratr Adaptr</h3>
<p>Move iteratr C++11 ile dile eklendi.</p>
<p><strong>Adaptr</strong>: Adaptr tasarm paternini implemente eden bir snf. STL iinde:</p>
<ul>
<li>Fonksiyon adaptrleri: Bir callable alyor ve bir callable geri veriyor.</li>
<li>Container adaptrleri: <code>Stack</code>, <code>queue</code>, <code>priority_queue</code>. Bir container' data member olarak alyorlar ve o container'n interfaceini kullanarak kendi interface'ini oluturuyorlar.</li>
<li>Iterator adaptrleri: <code>reverse_iterator</code>, <code>move_iterator</code>, Bir tane iteratr alyor ve onun interface'ini kendi kullanm amacna gre uyarlyor.</li>
</ul>
<p>2 ekilde adaptr oluturulabilir:</p>
<ul>
<li>Biri container adaptr gibi veri eleman yaparak</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>
     </span>{
        mc.<span class="hljs-built_in">func</span>();
     }
<span class="hljs-keyword">private</span>:
    C mc;
};
</code></pre>
<ul>
<li>Kaltm yoluyla:</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Iter&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Myiterator</span> : <span class="hljs-keyword">public</span> Iter
{

};
</code></pre>
<p><code>move_iterator&lt;vector&lt;int&gt;::iterator&gt; iter;</code> gibi kullanlabilir.</p>
<pre><code class="language-c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Iter&gt;
<span class="hljs-function"><span class="hljs-keyword">typename</span> std::move_iterator&lt;Iter&gt; <span class="hljs-title">MakeMoveIterator</span><span class="hljs-params">(Iter it)</span>
</span>{
    <span class="hljs-keyword">return</span> std::move_iterator&lt;Iter&gt;{it};
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    vecor&lt;string&gt;svec{<span class="hljs-string">&quot;ali&quot;</span>, <span class="hljs-string">&quot;veli&quot;</span>, <span class="hljs-string">&quot;selami&quot;</span>, <span class="hljs-string">&quot;necati&quot;</span>};
    <span class="hljs-comment">//biz move iterator oluturmak istiyoruz </span>
    
    <span class="hljs-comment">//1.si aka tr yazmak</span>
    moev_iterator&lt;vector&lt;string&gt;::iterator&gt; iter{svec.<span class="hljs-built_in">begin</span>()};

    <span class="hljs-comment">//2.si CTAD kullanlarak. C++17 ve sonrasnda geldi </span>
    move_iterator iter2{svec.<span class="hljs-built_in">begin</span>()};

    <span class="hljs-comment">//3.s ise bir fabrika fonksiyonu ile</span>
    <span class="hljs-keyword">auto</span> miter = <span class="hljs-built_in">make_move_iterator</span>(svec.<span class="hljs-built_in">begin</span>());    
}
</code></pre>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    vecor&lt;string&gt;svec{<span class="hljs-string">&quot;ali&quot;</span>, <span class="hljs-string">&quot;veli&quot;</span>, <span class="hljs-string">&quot;selami&quot;</span>, <span class="hljs-string">&quot;necati&quot;</span>};
    <span class="hljs-keyword">auto</span> miter = <span class="hljs-built_in">make_move_iterator</span>(svec.<span class="hljs-built_in">begin</span>());
    <span class="hljs-keyword">auto</span> name = *miter;
    cout&lt;&lt; svec[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">//ilk e tanm durumda ve 0 oluyor.</span>
}
</code></pre>
<p>Move iteratr dikkatli olunmak zorunda nk eer bu nesne 2.kez dereferense ederse move-from state'deki nesneyi kullanm oluyoruz ve bu tanmsz davran oluturuyor.</p>
<ul>
<li>Bu eleri container'n yelerini kullanarak yeni bir container'da kullanm olmak istiyoruz.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    vecor&lt;string&gt;svec{<span class="hljs-string">&quot;ali&quot;</span>, <span class="hljs-string">&quot;veli&quot;</span>, <span class="hljs-string">&quot;selami&quot;</span>, <span class="hljs-string">&quot;necati&quot;</span>};
    vecor&lt;string&gt;svec1{svec.<span class="hljs-built_in">begin</span>(), svec.<span class="hljs-built_in">end</span>()}; <span class="hljs-comment">//copy constructor arld.</span>

    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>; <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp; name : svec1)
    {
        cout&lt;&lt; ++cnt &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    }
    vector&lt;string&gt;mvsvec{move_iterator{svec.<span class="hljs-built_in">begin</span>()}, move_iterator{svec.<span class="hljs-built_in">end</span>()}}; <span class="hljs-comment">//move constructor arld.</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>; <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp; name : svec1)
    {
        cout&lt;&lt; ++cnt &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; name.<span class="hljs-built_in">length</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    }
}
</code></pre>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_something</span><span class="hljs-params">(std::string s)</span>
</span>{
    std::cout &lt;&lt; <span class="hljs-string">&quot;fonksiyona gelen sisim&quot;</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    vector&lt;string&gt;svec;
    <span class="hljs-built_in">rfill</span>(svec,<span class="hljs-number">10</span>,rname); <span class="hljs-comment">//nutility.h&#x27;dan geliyor ve vector&#x27; random olarak dolduruyor.</span>
    <span class="hljs-comment">//fonksiyona iinde i &#x27;harfi geenleri fonksiyona gndermek istiyoruz.</span>
    for_each(svec.<span class="hljs-built_in">begin</span>(), <span class="hljs-built_in">make_move_iterator</span>(svec.<span class="hljs-built_in">end</span>()),
    <span class="hljs-comment">//referans olursa sentaks hatas olur nk r-value dnm olur</span>
    <span class="hljs-comment">//[](string &amp;str) </span>
    <span class="hljs-comment">//[](string &amp;&amp;str) bu-da olmaz nk hala l-val expression. Bunun iin do_something&#x27;te move yapmamz lazm.</span>
    [](string str) 
    {
        <span class="hljs-keyword">if</span>(str.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;i&#x27;</span>) != string::npos)
            <span class="hljs-built_in">do_something</span>((str));
    });
    
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;name : svec)
    {
        cout&lt;&lt; ++count &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    }
}
</code></pre>
<h2 id="literal-operator-functions">Literal Operator Functions</h2>
<ul>
<li>Bir tamsay sabitini yazarken digit separator kullanlabiliyor.</li>
</ul>
<p><code>87'13821312'2132313'</code> gibi. Kullanlabiliyor. Magic numberlar ile kullanldn da bu kodun okunabilirliini arttryor. Hangi say tr ile yazldnn sabitin hangi tabanda yazld ile alakas yok <code>0x1a'cff</code>.</p>
<h3 id="userdefined-literal">Userdefined Literal</h3>
<p>Dilin core sentaks ierisinde nasl kullanlan sabitler olduu gibi. Biz de kendi sabitlerimizi oluturabiliyoruz.</p>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-number">354u</span>;
    <span class="hljs-string">&quot;alican&quot;</span>s;
}
</code></pre>
<ul>
<li>STL'in sunduu literal operatrler.</li>
<li>Programcnn kendisi de byle fonksiyonlar tanmlayabiliyor ve programcnn oluturduu trler iin de kullanlabiliyor.</li>
</ul>
<p><code>743ms</code> yazdmzda burada bir fonksiyon ars yaplyor. Biz byle bir ifadeyi derleyici baz fonksiyonlar var ise bunu bir ar koduna deitiriyor. Burada arlan free function <code>constexpr</code> bir fonksiyonda olabilir ve buradan elde edilen ifade bir compile time sabiti oluyor.</p>
<ul>
<li>Bu fonksiyonlarn grnr olmas durumunda isimleri ile arabiliyoruz.</li>
</ul>
<ol>
<li>Bu fonksiyonlar keyfi olarak parametre trleri alamyor. Parametre deikenlerinin hangi trden olabileceine ait sentaks kurallar var.</li>
<li>Fonksiyonun sadece parametrelerine ilikin bir kural var geri dn deeri iin programcy engelleyen bir durum yok.</li>
<li>Suffix olarak kullanlan isim fonksiyonun ismi ve programcnn yazaca custom type iin <code>_&lt;isim&gt;</code> eklinde olmal.</li>
</ol>
<p>Bunlar 2 ayr kategoride oluyor:</p>
<ul>
<li>
<p><strong>Cooked</strong>: Eer bir tam say kullanarak ve ona son ek eklenecekse, derleyici bu ifadeyi dorudan bir tam say olarak gnderiyor.
<code>312321_m</code> =&gt; <code>operator&quot;&quot;_m(unsigned long long)</code> ile trden unsigend long long paramtresine 312321 olarak gnderiliyor.</p>
</li>
<li>
<p><strong>Uncooked</strong>: arlan fonksiyonun parametresi c-string ve bu yukardaki gibi bir fonksiyon ise <code>operator&quot;&quot;_m(const char *p)</code> bu fonksiyona &quot;312321&quot; olarak gnderiliyor ve artk bu yazy karakter karakter olarak dolaabiliriz.</p>
</li>
<li>
<p>Tam say ve gerek saylar iin cooked/uncooked yazma ansmz var.</p>
</li>
<li>
<p>Bu fonksiyonlar namespace ierisinde sun.</p>
</li>
<li>
<p><strong>unsigned long long</strong>/<strong>char</strong> olmal</p>
</li>
</ul>
<pre><code class="language-c++"><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span>_sr(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> val)
{
    std::cout&lt;&lt;<span class="hljs-string">&quot;operator_k -&gt;  val = &quot;</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(std::<span class="hljs-built_in">sqrt</span>(val));
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    <span class="hljs-keyword">auto</span> x = <span class="hljs-number">843712</span>_sr;
    cout&lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-keyword">auto</span> = <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span>_sr(<span class="hljs-number">843712</span>); <span class="hljs-comment">//eklinde de arlabilir.</span>
}
</code></pre>
<ul>
<li><strong>uncooked</strong> olarak bu fonksiyon yazlsayd:</li>
</ul>
<pre><code class="language-c++"><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span>_sr(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *p)
{
    std::cout&lt;&lt;<span class="hljs-string">&quot;operator_k -&gt;  val = &quot;</span> &lt;&lt; std::<span class="hljs-built_in">strlen</span>(p) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-keyword">while</span>(*p)
    {
        std::cout &lt;&lt; *p &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)*p&lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
        ++p;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">auto</span> val = <span class="hljs-number">823.3232</span>_sr
}
</code></pre>
<p>yle bir son ek olsunki 2'lik say sisteminde bir sayya denk gelsin</p>
<pre><code class="language-c++"><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span>_b2(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *p)
{
    <span class="hljs-type">int</span> val{};
    <span class="hljs-keyword">while</span>(*p)
    {
        <span class="hljs-keyword">if</span>(*p == <span class="hljs-string">&#x27;0&#x27;</span>|| *p == <span class="hljs-string">&#x27;1&#x27;</span>)
            val = val * <span class="hljs-number">2</span> + (*p - <span class="hljs-string">&#x27;0&#x27;</span>);
        <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">throw</span> std::invalid_argument{<span class="hljs-string">&quot;invalid binary digit&quot;</span>};
        ++p;
    }
    <span class="hljs-keyword">return</span> val;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">auto</span> val = <span class="hljs-number">101011101</span>_b2;
}
</code></pre>
<ul>
<li>Gerek say sabiti iinse <code>long double val</code> trden bir deiken olmak zorunda.</li>
</ul>
</div>
        </div>
            
            
        </body>
        </html>